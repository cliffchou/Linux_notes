1.exit 关闭终端
2.在Linux文件系统中跳转 
  • pwd —打印出当前工作目录名 
  • cd —更改目录 
  • ls —列出目录内容
  
  快捷键：  
  cd 更改工作目录到你的家目录。 
  cd - 更改工作目录到先前的工作目录。 
  cd ˜user name 更改工作目录到用户家目录。例如, cd ˜bob 会更改工作目 录到用户“bob”的家目录。
  
3.有利于研究linux系统的命令 
  • ls —列出目录内容。
       —除了当前目录外，也可以指定要列出内容的目录，例如 $ ls /usr 。甚至可以列出多个指定目录的内容，例如 $ ls ~ /usr 将列出用户家目录和/usr目录的内容。
	   —ls -l 结果以长模式输出
  • ﬁle —确定文件类型（file filename 会打印文件内容的简单描述） 
  • less —浏览文件内容(less filename 允许你上下滚动文件，按“q”键退出less程序)
  
  ls命令的选项：
  选项 长选项
  -a   --all 列出所有文件，甚至包括文件名以圆点开头的默认会 被隐藏的隐藏文件。
  -d   --directory 通常，如果指定了目录名，ls 命令会列出这个目录中 的内容，而不是目录本身。把这个选项与 -l 选项结合 使用，可以看到所指定目录的详细信息，而不是目录中的内容。 
  -F   --classify 这个选项会在每个所列出的名字后面加上一个指示 符。例如，如果名字是目录名，则会加上一个’/’ 字 符。 
  -h   --human-readable 当以长格式列出时，以人们可读的格式，而不是以字 节数来显示文件的大小。 
  -l 以长格式显示结果。 
  -r   --reverse 以相反的顺序来显示结果。通常，ls 命令的输出结果 按照字母升序排列。 
  -S 命令输出结果按照文件大小来排序。 
  -t 按照修改时间来排序。

  less程序最常用的键盘命令：
  命令                行为
  Page UP or b        向上翻滚一页（page UP在键盘上面有）
  Page Down or space  向下翻滚一页
  UP Arrow            向上翻滚一行（上箭头）
  Down Arrow          向下翻滚一行
  G                   移动到最后一行
  1G or g             移动到开头一行
  /charaters          向前查找指定的字符串
  n                   向前查找下一个出现的字符串，这个字符串是之前所指定查找的
  h                   显示帮助屏幕
  q                   退出 less 程序

4.操作文件和目录
  • cp —复制文件和目录（cp item1 item2; cp item... directory 复制一个或多个项目（或文件）到后面哪个目标目录（或文件）下）
  • mv —移动/重命名文件和目录
  • mkdir —创建目录
  • rm —删除文件和目录（rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变）
  • ln —创建硬链接和符号链接（ln file link 创建硬链接；ln -s item link 创建软链接，item可以是一个文件或是一个目录）

===>>
===>>

  通配符：
  通配符          意义
  *               匹配任意多个字符（包括零个或一个）
  ?               匹配任意一个字符（不包括零个）
  [characters]    匹配任意一个属于字符集中的字符
  [!characters]   匹配任意一个不是字符集中的字符
  [[:class:]]     匹配任意一个属于指定字符类中的字符
  
  最常用的字符类：
  字符类          意义
  [:alnum:]       匹配任意一个字母或数字
  [:alpha:]       匹配任意一个字母
  [:digit:]       匹配任意一个数字
  [:lower:]       匹配任意一个小写字母
  [:upper]        匹配任意一个大写字母
  
  范例：
  模式            匹配对象
  *               所有文件
  g*              文件名以“g”开头的文件
  b*.txt          以”b” 开头，中间有零个或任意多个字符，并以”.txt” 结尾的文件
  Data???         以“Data”开头，其后紧接着 3 个字符的文件
  [abc]*          文件名以”a”,”b”, 或”c” 开头的文件
  BACKUP.[0-9][0-9][0-9] 以”BACKUP.” 开头，并紧接着 3 个数字的文件
  [[:upper:]]*    以大写字母开头的文件
  [![:digit:]]*   不以数字开头的文件
  *[[:lower:]123] 文件名以小写字母结尾，或以“1”，“2”，或“3”结尾的文件
  
  cp命令一些有用选项：
  选项                   意义 
  -a, --archive          复制文件和目录，以及它们的属性，包括所有权和权限。通常，复本具有用户所操作文件的默认属性。 
  -i, --interactive      在重写已存在文件之前，提示用户确认。如果这个选项不指定，cp命令会默认重写文件。 
  -r, --recursive        递归地复制目录及目录中的内容。当复制目录时，需要这个选项（或者 -a 选项）。 
  -u, --update           当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 
  -v, --verbose          显示翔实的命令操作信息
  -b                     文件被覆盖之前做简单备份（-b不接受参数，）
  
  mv命令一些有用选项：
  选项                  意义 
  -i --interactive      在重写一个已经存在的文件之前，提示用户确认信息。 mv命令本来就会提示是否覆盖，只要不加入 -f 即可。 
  -u --update           当把文件从一个目录移动另一个目录时，只是移动不存在的文件，或者文件内容新于目标目录相对应文件的内容。 
  -v --verbose          当操作 mv 命令时，显示翔实的操作信息
  典例：mv * ../ 移动当前文件夹下的所有文件到上一级目录
        mv test3/*.txt test2 把当前目录的一个子目录里的文件移动到另一个子目录里
  注意：1) mv dir1 dir2 目录的移动，但若目录dir2不存在，则会将dir1改名为dir2.
        2) 你只能操作当前目录下的目录（或文件）及其子目录（或文件），而且当前目录下，若不指定目标目录，那么默认目标目录是当前目录。
           例如：mv file1/xiu.txt xiuxiu.txt 先将file1中的文件改名，再移动到当前目录中来（其实 xiuxiu.txt 实际为/xiuxiu.txt） 		
        3) 移动还是改名，就看目标对象到底是目录（dir,file），还是文件（.txt, .log ...）。其实本质上讲都是移动，不存在的再创建一个，移动后再删除原来的，看起来就像改了名一样，神奇不。
  
  rm命令一些有用选项：
  选项                  意义 
  -i, --interactive     在删除已存在的文件前，提示用户确认信息。 如果不指定 这个选项，rm 会默默地删除文件 
  -r, --recursive       递归地删除文件，这意味着，如果要删除一个目录，而此目录又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 
  -f, --force           忽视不存在的文件，不显示提示信息。这选项颠覆了“-interactive”选项。 
  -v, --verbose         在执行 rm 命令时，显示翔实的操作信息。
  注意：rm 无法直接删除一个目录，必须用-r递归删除
  
  ln创建硬链接和符号链接：
  1) ls -li 展示索引节点的信息
  
5.man 显示程序手册页(命令的帮助文档)

  man 所显示的参考手册是分章节的，以下细分之...
  章节      内容
   1        用户命令
   2        程序接口内核系统调用
   3        C 库函数程序接口
   4        特殊文件，比如说设备结点和驱动程序
   5        文件格式
   6        游戏娱乐，如屏幕保护程序
   7        其他方面
   8        系统管理员命令
  
  apropos 显示适当的命令（可以基于某个关键字的匹配项，搜索参考手册列表）
  注意：man命令加上“-k”选项，和apropos完成一样的功能
  
  whatis 显示非常简洁的命令说明（whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明）
  
  info 显示程序 Info 条目
  当显示一个info页面时，以下命令用来控制阅读器：
  命令                行为
   ?                  显示命令帮助
  PgUp or Backspace   显示上一页
  PgDn or Space       显示下一页
   n                  下一个 - 显示下一个结点
   p                  上一个 - 显示上一个结点
   u Up - 显示当前所显示结点的父结点，通常是个菜单
   Enter               激活光标位置下的超级链接
   q                  退出
    
7. 用别名（alias）创建你自己的命令: alias name='string'
   1) 创建之前，建议先用 type 命令查看下该名字是否已被占用；
   2) 然后再通过 alias 创建属于自己的命令，如 $ alias foo='cd /usr; ls; cd ~'
   3) 删除别名，用 unalias 命令，如 $ unalias foo
   
8.I/O重定向
  • cat    －连接文件（命令读取一个或多个文件，然后复制它们到标准输出，cat [file]）
  • sort   －排序文本行
  • uniq   －报道或省略重复行(通常与sort一起用，从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行)
  • grep   －打印匹配行(找文件中匹配文本)
  • wc     －打印文件中换行符，字，和字节个数
  • head   －输出文件第一部分(head命令打印文件的前十行,可以通过参数 -n 来调整打印具体行数)
  • tail   －输出文件最后一部分(tail 命令打印文件的后十行,可以通过参数 -n 来调整打印具体行数)
   
==>重定向标准输出：$ ls -l /bin/usr > ls-output.txt
                          存在的目录  重定向标准输出目标文件
   
   删除一个文件内容（或创建一个新的空文件）：$ > ls-output.txt 
   因为当我们使用 “>” 重定向符来重定向输出结果时，目标文件总是从开头被重写。也就是说简单地使用重定向符，没有命令在它之前，这会删除一个已存在文件的内容或是创建一个新的空文件。
   
==>重定向标准错误：$ ls -l /bin/usr 2> ls-error.txt      此处是 /bin/usr ，即只有错误输出才能输出到该重定向文件中，倘若你用 /usr/bin 表示，只能在屏幕上输出文本内容，并不能输出到该重定向文件中
   注意：因为标准错误和文件描述符 2 一样，所以我们用文本描述符来重定向标准错误。文件描述符 “2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt任务。
         同理，>> 表示不会删除目标文件中原有的内容，而是接着在其后面输出标准错误
   
==>重定向标准输出、标准错误到同一个文件：1)$ ls -l /bin/usr > ls-output.txt 2>&1     注意 2>&1 这几个命令是紧挨在一起的
                                           该方法完成了两个重定向，首先重定向标准输出到文件 ls-output.txt，然后重定向文件描述符 2（标准错误）到文件描述符 1（标准输出）使用表示法 2>&1。  
                                         2)$ ls -l /bin/usr &> ls-output.txt
										   我们使用单单一个表示法 &> 来重定向标准输出和错误到文件 lsoutput.txt
   注意：重定向是一个“一次性”操作，并不是说你重定向一次就一劳永逸了，每次你不指定系统就默认输出到屏幕上去
   
   
==>重定向标准输入
   1)由于文件名参数的缺席， cat 复制标准输入到标准输出，所以我们看到文本行重复出现。我们可以使用这种行为来创建简短的文本文件
     $ cat > lazy_dog.txt          记得最后输入 Ctrl-d
   2)"<" 重定向标准输入： $ cat < lazy_dog.txt 将标准输入从键盘重定向为 lazy_dog.txt 文件
   
==>管道线：|  使用管道操作符“|”（竖杠），一个命令的标准输出可以管道到另一个命令的标准输入
   例如：less 可以接受标准输入，因此我们可以利用less命令一页一页地显示任何命令的输出，把它们的运行结果送到标准输出
         $ls -l /usr/bin | less   我们可以方便地检测会产生标准输出的任一命令的运行结果
   
==>grep pattern [file...]   当 grep 遇到一个文件中的匹配 “模式”，它会打印出包含这个类型的行。没有file命令参数，则会接受一个标准输入。
   参数：“-i” 导致 grep 忽略大小写当执行搜索时（通常，搜索是大小写敏感的）， 
         “-v” 选项会告诉 grep 只打印不匹配的行.
		 
==>$ tail -f /var/log/messages  可以动态显示该 messages 文件的动态更新
   注意：-f 的只有在其输入为档案时才能使用;
         假如你在 tail 后下了多个档案参数，你便能在同一个窗口内一次追踪数个 log 档.
==>tee 从标准输入读取数据，并同时复制数据到标准输出和一个或多个文件（注意是同时啊，也就是说允许数据继续随着管道线流动）
   用途：在某个中间处理阶段来捕捉一个管道线的内容
   
Linux is about imagination
   
9.echo 显示一行文本（在标准输出中打印出它的文本参数）  
  1) echo * 显示当前目录下的所有文件名（此处 shell 在 echo 命令被执行前，将 * 展开为任何符合条件的字符）
     注意：该程序不会显示隐藏文件（以 . 开头）,若想展开，需以 .* 
  2) .* 显示了当前工作目录和它的父目录(. ..)，该模式可能会产生不对的结果，等效于 ls -d .* | less      
     若想正确完成路径名的展开，可以用更精确模式
	 ls -d .[!.]?*
  3) 算术表达式展开: $((expression))
      shell允许算术表达式通过展开来执行，注意里面的表达式只能用于整数（不存在小数点）
  4) 花括号展开
     你可以从一个包含花括号的模式中创建多个文本字符串，例如 $echo Front-{A,B,C}-Back  --> Front-A-Back Front-B-Back Front-C-Back
	 注意：该模式不能嵌入空白字符串
   
10.clear  清空屏幕
   history  显示历史列表内容
   
==>移动光标
   按键         行动
   Ctrl-a       移动光标到行首。
   Ctrl-e       移动光标到行尾。
   Ctrl-f       光标前移一个字符；和右箭头作用一样。
   Ctrl-b       光标后移一个字符；和左箭头作用一样。
   Alt-f        光标前移一个字。
   Alt-b        光标后移一个字。
   Ctrl-l       清空屏幕，移动光标到左上角。clear 命令完成同样的工作。
  
==>修改文本
   按键         行动
   Ctrl-d       删除光标位置的字符。
   Ctrl-t       光标位置的字符和光标前面的字符互换位置。
   Alt-t        光标位置的字和其前面的字互换位置。
   Alt-l        把从光标位置到字尾的字符转换成小写字母。
   Alt-u        把从光标位置到字尾的字符转换成大写字母。
  
==>剪切和粘贴文本
   按键          行动
   Ctrl-k        剪切从光标位置到行尾的文本。
   Ctrl-u        剪切从光标位置到行首的文本。
   Alt-d         剪切从光标位置到词尾的文本。
   Alt-Backspace 剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。
   Ctrl-y        把剪切环中的文本粘贴到光标位置。
  
==>自动补全
   按键     行动
   Alt-?    显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按两次 tab 键，这会更容易些。
   Alt-*    插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助
  
==>搜索所有历史命令 $ history | less 
   搜索指定历史命令 $ history | grep /usr/bin    #找到列出目录/usr/bin 内容的命令（all）
   历史命令展开：!number  #其中这个 number 就是该命令在历史列表中的行号，历史命令展开会得到对应命令执行后的内容
   递增搜索：按下 Ctrl-r 接着输入你要搜索的内容即可（多次输入 Ctrl-r，功能是向上移动历史列表）
   退出搜索：Ctrl-g 和 Ctrl-c
   
   操作历史记录的按键组合
   按键        行为
   Ctrl-p      移动到上一个历史条目。类似于上箭头按键。
   Ctrl-n      移动到下一个历史条目。类似于下箭头按键。
   Alt-<       移动到历史列表开头。
   Alt->       移动到历史列表结尾，即当前命令行。
   Ctrl-r      反向递增搜索。从当前命令行开始，向上递增搜索。
   Alt-p       反向搜索，不是递增顺序。输入要查找的字符串，然后按下Enter，执行搜索。
   Alt-n       向前搜索，非递增顺序。
   Ctrl-o      执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便
  
   历史命令展开
   序列       行为
   !!         重复最后一次执行的命令。可能按下上箭头按键和 enter 
   !number    重复历史列表中第 number 行的命令。
   !string    重复最近历史列表中，以这个字符串开头的命令。
   !?string   重复最近历史列表中，包含这个字符串的命令。
  
11.用户权限命令
   • id –显示用户身份号
   • chmod –更改文件模式
   • umask –设置默认的文件权限
   • su –以另一个用户的身份来运行 shell
   • sudo –以另一个用户的身份来执行命令
   • chown –更改文件所有者
   • chgrp –更改文件组所有权
   • passwd –更改用户密码
  
==>ls命令输出的前十个字符是文件属性：
   1) 第一个字符表明文件类型，有如下
      属性      文件类型
      -         一个普通文件
      d         一个目录
      l         一个符号链接。注意对于符号链接文件，剩余的文件属性总是”rwxrwxrwx”，而且都是虚拟值。真正的文件属性是指符号链接所指向的文件的属性。
      c         一个字符设备文件。这种文件类型是指按照字节流，来处理数据的设备。比如说终端机，或者调制解调器
      b         一个块设备文件。这种文件类型是指按照数据块，来处理数据的设备，例如一个硬盘，或者 CD-ROM 盘。
   2) 剩下的九个字符，叫做文件模式，代表着文件所有者，文件组所有者，和其他人的读，写，执行权限。

==>chmod 更改文件或目录模式(权限)，注意只有文件的所有者或者超级用户才能更改文件或目录的模式
   
   八进制表示法设置权限模式：chmod 600 foo.txt  #-rw 设置文件所有者的权限为读写权限，而删除用户组和其他人的所有权限
   Octal     Binary    File Mode
     0         000       -–
     1         001       --x
     2         010       -w-
     3         011       -wx
     4         100       r-- 
     5         101       r-x
     6         110       rw-
     7         111       rwx
      
   符号表示法指定文件模式：
   u+x         为文件所有者添加可执行权限。
   u-x         删除文件所有者的可执行权限。
   +x          为文件所有者，用户组，和其他所有人添加可执行权限。等价于 a+x。
   o-rw        除了文件所有者和用户组，删除其他人的读权限和写权限。
   go=rw       给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。
   u+x,go=rw   给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。
  
==>su -l username 为指定用户启动一个需要登录的shell，不指定则会默认登录到超级用户(-l 可以简写为 -) 
  
==>chown 更改文件或目录的所有者和用户组.
   chown [owner][:[group]] file...
   
   chown参数实例
   参数        结果
   bob         把文件所有者从当前属主更改为用户 bob。
   bob:users   把文件所有者改为用户 bob，文件用户组改为用户组 users。
   :admins     把文件用户组改为组 admins，文件所有者不变。
   bob:        文件所有者改为用户 bob，文件用户组改为，用户 bob 登录系统时，所属的用户组。
   
==>Linux创建用户、用户组及删除
   一、用户组操作
	1.创建用户组
	  groupadd -g 888 users
	  --创建一个组users，其GID为888
	2.修改用户组
	  groupmod -n user users
	  --修改组名users为user
	3.删除用户组
	  groupdel users
	4.用户组添加、移除用户
	  注：只有root和组管理员能够改变组的成员
	  例：把user1加入users组
	      gpasswd -a user1 users
	  例：把user1退出users组
	      gpasswd -d user1 users
	5.查看用户组下所有用户
	  groups username 显示用户所属的用户组
	  
	  whoami 查看当前登录用户名
	  
	  /etc/group 文件包含了所有组(包括组内所有用户)
	  /etc/shadow和/etc/passwd 文件包含了系统存在的所有用户名
   二、用户操作
	  创建用户
	  useradd user1 --创建用户user1
	  useradd -e 12/30/2016 user2 --创建user2，指定有效期2016/12/30到期
	  useradd -u 600 user3 --指定user3的UID为600
	  用户缺省UID的从500向后顺序增加，500以下作为系统保留账号
	  创建用户user并指定用户组users
	  useradd -g user users 
	
	注意：具体可参考博客园收藏“linux下查看用户及用户组”

==>更改用户密码 passwd [user]

12.进程相关命令
   • ps       –报告当前进程快照(查看进程)
   • top      –显示任务
   • jobs     –列出活跃的任务
   • bg       –把一个任务放到后台执行
   • fg       –把一个任务放到前台执行
   • kill     –给一个进程发送信号
   • killall  –杀死指定名字的进程
   • shutdown –关机或重启系统 	
   
==>ps的相关控制选项
   x 告诉 ps 命令，展示所有进程，不管它们由什么终端（如果有的话）控制(“?” ，表示没有控制终端)
   aux 这个选项组合，能够显示属于每个用户的进程信息
   
==>top命令动态查看进程(默认三分钟更新一次信息)
   1)top程序是用来查看系统中“顶端”进程的
   2)top显示结果分为两部分，最上面的是系统概要，下面是进程列表，以CPU的使用率排序
   
==>把一个进程放在后台执行：就在相应程序(命令)之后加上 &
   让一个进程返回前台执行：fg %[工作序号]        #后台运行的进程对一切来自键盘的输入都免疫，不能用 Ctrl-c 来中断它。可以先用左边命令让进程返回前台执行，再来 Ctrl-c 来中断进程。
   
   停止进程(并不是终止它，而是把一个前台进程移到后台等待): Ctrl-z
   恢复一个停止的进程：fg命令(恢复程序到前台运行) 或者 bg 命令(把程序移到后台)
   
==>kill [signal] PID/%[jobspec] kill命令给进程发信号(不指定具体信号，则默认发送终止信号)
   常用信号
   编号 名字 含义
   1    hup  挂起。这是美好往昔的痕迹，那时候终端机通过电话线和调制解调器连接到远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂起”。通过关闭
                   一个终端会话，可以说明这个信号的作用。发送这个信号到终端机上的前台程序，程序会终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当
                   发送这个信号到一个守护进程后，这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。
   2    int  中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。
   9    kill 杀死。这个信号很特别。鉴于进程可能会选择不同的方式，来处理发送给它的信号，其中也包含忽略信号，这样呢，从不发送 Kill 信号到目标进程。而是内核立
                   即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存劳动成果。因为这个原因，把 KILL 信号看作杀手锏，当其
                   它终止信号失败后，再使用它。
  15    term 终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么这个信号终止。
  18    cont 继续。在停止一段时间后，进程恢复运行。
  19    stop 停止。这个信号导致进程停止运行，而没有终止。像KILL 信号，它不被发送到目标进程，因此它不能被忽略。
  
  注意：信号既可以用号码，也可以用名字，不过名字前要加上字母“SIG”，来指定所要发送的信号。例如 SIGHUP、SIGINT...  
        你必须拥有超级用户权限才可以给不属于你的进程发送信号。
  
==>killall 命令给多个进程发送信号(你必须拥有超级用户权限才可以给不属于你的进程发送信号)
   killall [-u user] [-signal] name... 

==>其它和进程相关的命令
   命令名      命令描述
   pstree      输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。
   vmstat      输出一个系统资源使用快照，包括内存，交换分区和磁盘I/O。为了看到连续的显示结果，则在命令名后加上延时的时间（以秒为单位）。例如，“vmstat 5”。终止输出，按下Ctrl-c 组合键。
   xload       一个图形界面程序，可以画出系统负载的图形。
   tload       与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出

13.shell环境中的相关命令
   • printenv - 打印部分或所有的环境变量(只是显示环境变量)
   • set      - 设置 shell 选项(可以显示 shell 和 环境变量)
   • export   - 导出环境变量，让随后执行的程序知道。
   • alias    - 创建命令别名
   
   1)查看一个变量的内容
     printenv variable
     echo $variable
   2)PATH 变量在 /etc/profile 启动文件中设置
     ~/.bashrc 是最重要的启动文件，几乎总被读取
   3)文本编辑器nano
     Ctrl-x 退出nano(^X就是代表Ctrl-x)
	 Ctrl-o 保存文本
	 
   4)source .bashrc 强迫bash重新读取修改过的 .bashrc 文件(因为 .bashrc 文件只是在刚开始启动终端会话时读取，所以对于 .bashrc 文件的修改并不会立即生效，除非关闭终端会话并重新启动一个会话)
   
14.vi文本编辑器
   vi 启动vi
   :q 退出vi(倘若是修改了文件还没保存，那么就无法退出。可以使用 :q! 强制性退出 vi) 
   vi [filename] 给vi传递一个不存在的文件名，来创建新文件
   :w 保存文件(文件将会被写入到硬盘，执行 :wq 会先保存后退出)
   
   注意：输入命令控制是在命令模式下，先输入 : ，然后输入相应的命令即可;
         如果你在 vi 中“迷失”了，试着按下 Esc 键两次来找到路（回到普通模式）;

==>与 less 阅读器共享的移动命令(区分大小写，比如 G 就得大写)
   按键     	移动光标
   l or 		右箭头 向右移动一个字符
   h or 左箭头  向左移动一个字符
   j or 下箭头  向下移动一行
   k or 上箭头  向上移动一行
   0 (零按键)   移动到当前行的行首。
   ˆ 			移动到当前行的第一个非空字符。
   $ 			移动到当前行的末尾。***
   w 			移动到下一个单词或标点符号的开头。   
   W 			移动到下一个单词的开头，忽略标点符号。
   b 			移动到上一个单词或标点符号的开头。
   B 			移动到上一个单词的开头，忽略标点符号。
   Ctrl-f or Page Down 向下翻一页
   Ctrl-b or Page Up   向上翻一页
   numberG 			   移动到第 number 行。例如， 1G 移动到文件的第一行。
   G 			移动到文件最后一行的开头。
   
==>文本基本操作
   vi进入插入模式的几种不同方法：
       i 插入文本  
       a 追加文本命令
	   A 行尾追加文本
	   o 当前行的下方打开一行
	   O 当前行的上方打开一行

==>撤销	   
   u 撤销修改(一次性撤销上次保存后的所有修改)
   CTRL-R（redo） 如果你撤销得太多，你可以输入CTRL-R（redo）回退前一个命令。换句话说，它撤销一个撤销。
   
==>文本删除命令：
   命令   删除的文本
   x      当前字符
   3x     当前字符及其后的两个字符(也就是它的左边，先输入的字符)。
   dd     当前行。
   5dd    当前行及随后的四行文本(一共5行)。
   dW     从光标位置开始到下一个单词的开头。
   d$     从光标位置开始到当前行的行尾。
   d0     从光标位置开始到当前行的行首。
   dˆ     从光标位置开始到文本行的第一个非空字符。
   dG     从当前行到文件的末尾。
   d20G   从当前行到文件的第 20 行。
   注意：1)真正的 vi 只是支持单层面的 undo 命令，而 vim 则支持多个层面的
         2)d 命令其实是“剪切”了文本
   
   拓展：清空vim文本内容，非插入模式下
         :.,$d + 回车
   
==>剪切、复制、粘贴命令
   剪切命令(也为删除命令)：
   d 
   
   粘贴命令：
   (小)p  将已复制的数据在光标下一行粘贴
   (大)P 或者 Shift + p  将已复制的数据在光标上一行粘贴
   
   复制命令：
   命令    复制的内容
   yy      当前行。
   5yy     当前行及随后的四行文本。
   yW      从当前光标位置到下一个单词的开头。
   y$      从当前光标位置到当前行的末尾。
   y0      从当前光标位置到行首。
   yˆ      从当前光标位置到文本行的第一个非空字符。
   yG      从当前行到文件末尾。
   y20G    从当前行到文件的第 20 行。
   
==>连接行
   J   
   
==>查找和替换
   查找
   f 查找一行，移动光标到下一个所指定的字符上。例如 fa 会把光标定位到同一行中下一个出现的“a”字符上。
   / 查找整个文件，通过 n 命令来重复先前的查找(也即是查找下一个)   
   
   替换
   :%s/Line/line/g
   条目       含义
   :          冒号字符运行一个 ex 命令。
   %          指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行，等效于“1,$”。另外，操作范围也可以用 1,5 来代替（因为我们的文件只有 5 行文本），或者用 1,$ 来代替，意思是“从第
              一行到文件的最后一行”。如果省略了文本行的范围，那么操作只对当前行生效。 例如，:1,5s/Line/line/g 表示操作对象为1到5行文本， :.,$s/Line/line/g 表示从当前行到文件末尾
   s          指定操作。在这种情况下是，替换（查找与替代）。
   /Line/line 查找类型与替代文本。
   g          这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则只替换每个文本行中第一个匹配的字符串。
   
   注意：通过在命令的末尾加上一个c，我们可以指定一个需要用户确认的替换命令，确认一个便执行一个替换(:%s/Line/line/gc)
   
   替换确认按键：
   按键           行为
   y              执行替换操作
   n              跳过这个匹配的实例
   a              对这个及随后所有匹配的字符串执行替换操作。
   q or esc       退出替换操作。
   l              执行这次替换并退出。l 是“last”的简写。
   Ctrl-e, Ctrl-y 分别是向下滚动和向上滚动。用于查看建议替换的上下文。
   
==>编辑多个文本文件
   vi file1 file2 file3...    注意各个文件名之间没有逗号隔开
   :n 从这个文件转到下一个文件(如果当前文件没有保存修改，vi 会阻止我们转换文件，这是 vi 强制执行的政策。在命令之后添加感叹号，可以强迫 vi *放弃修改*而转换文件)
   :N 回到先前的文件使用
   :buffers  查看正在编辑的文件列表
   
   注意：你不能通过:n 或:N 命令在由:e 命令加载的文件之间进行切换。这时要使用:buffer 命令，其后加上缓冲区号码，来转换文件。
   
   补充：:e          -- 重新加载当前文档。
         e!          -- 重新加载当前文档，并丢弃已做的改动。
         :e#或ctrl+^ -- 回到刚才编辑的文件，很实用。
         :f或ctrl+g  -- 显示文档名，是否修改，和光标位置。
   
   补充：在当前vi编辑器中，执行":e 新的文件"形式的末行命令可以编辑新文件。
         在当前vi编辑器中，执行":r 其他文件"形式的末行命令读入其他文件的内容，将其复制到当前光标的所在位置。
         在当前vi编辑器中，执行":r !命令"形式的末行模式，可以将其他命令的输出粘贴至文本文件光标所在位置。
         在末行模式执行"set number "命令可显示行号，执行"set nonu"取消显示行号。
		 
==>vim编辑器有用的参数
   vim -o file1  file2;将同时打开两个文件，上下显示，使用ctrl+w切换文件。
   vim -O file1  file2;将同时打开两个文件，左右显示，使用ctrl+ww切换文件。

==>从一个文件复制内容到另一个文件：buffer [缓冲区号]; ff; p...
   插入整个文件到另一个文件：:r foo.txt  此时你正在另一个待插入文件中(例如ls-output.txt)
   
==>保存工作
   1) :w [filename] 这个:w 命令也可以指定可选的文件名,这个的作用就如 “Save As. . . ”。当该命令以一个新名字保存文件时，它并没有更改你正在编辑的文件的名字。
   2) 在命令模式下，输入 ZZ 就会保存并退出当前文件
   
15.软件包管理
   1)软件包查找工具
     风格     命令
     Debian   apt-get update; apt-cache search search string
     Red Hat  yum search search string   
   
   2)软件包安装命令
     风格     命令
     Debian   apt-get update; apt-get install package name
     Red Hat  yum install package name
   
   3)底层软件包安装命令：从某处而不是资源库中下载一个软件包文件时，可以使用底层工具来直接安装它，不用经过依赖解析
     风格        命令
     Debian      dpkg --install package file
     Red Hat     rpm -i package file
   
   4)可以使用上层或底层工具来卸载软件，软件包删除命令
     风格        命令
     Debian      apt-get remove package name
     Red Hat     yum erase package name
   
   5)最常见的软件包管理任务是保持系统中的软件包都是最新的，软件包更新命令
     风格        命令
     Debian      apt-get update; apt-get upgrade
     Red Hat     yum update
   
   6)用软件包文件来升级软件(如果已经从一个非资源库网站下载了一个软件包的最新版本，可以安装这个版本，用它来替代先前的版本，底层软件包升级命令
     风格        命令
     Debian      dpkg --install package file
     Red Hat     rpm -U package file
   
   7)列出所安装的软件包命令
     风格        命令
     Debian      dpkg --list
     Red Hat     rpm -qa
   
   8)软件包状态命令，用来显示是否安装了指定的软件包
     风格        命令
     Debian      dpkg --status package name
     Red Hat     rpm -q package name
   
   9)查看软件包信息命令，前提是已知所安软件包的名字
     风格        命令
     Debian      apt-cache show package name
     Red Hat     yum info package name
	 
   10)查找软件包，确定哪个软件包对所安装的某个特殊文件负责，包文件识别命令
     风格        命令
     Debian      dpkg --search file name
     Red Hat     rpm -qf file name
	 
16.管理存储设备的命令
   • mount –挂载一个文件系统(执行这个不带参数的命令，将会显示一系列当前挂载的文件系统)
   • umount –卸载一个文件系统(超级用户身份)
   • fsck –检查和修复一个文件系统
   • fdisk –分区表控制器(允许我们直接在底层与类似磁盘的设备进行交互)
   • mkfs –创建文件系统
   • fdformat –格式化一张软盘
   • dd —把面向块的数据直接写入设备
   • genisoimage (mkisofs) –创建一个 ISO 9660 的映像文件
   • wodim (cdrecord) –把数据写入光存储媒介
   • md5sum –计算 MD5 检验码
   
   1)mount -> 显示列表格式：设备 on 挂载点 type 文件系统类型（可选内容）
   
   2)比如卸载一个光盘挂载点：# umount /dev/hdc  
     注意：当某个用户或者进程正在使用这个设备的话，你就不能卸载一个设备。真要卸载，就是把当前工作目录改到其它目录而不是这个挂载点。
	  
     重新挂载：先创建一个目录(该目录不必为空)        mkdir /mnt/cdrom
	           把这个CD-ROW 挂载到一个新的挂载点上   mount -t iso9660 /dev/hdc /mnt/cdrom
                                                         -t 指定文件类型
                                                         iso9660 文件系统类型(比如u盘就是 vfat )														 
   
   3)sudo tail -f /var/log/messages 可以实时观察系统的一举一动
   
   4)df 列出文件系统的整体磁盘使用量
     du 检查磁盘空间使用量
	 fdisk 用于磁盘分区
   
   5)使用 fdisk 程序直接在底层与类似磁盘设备进行交互(如何操作分区)：
          a)先卸载它 sudo umount /dev/sdb1
          b)调用 fdisk 程序，注意必须指定设备名称(就整个设备而言，而不是通过分区号) $fdisk /dev/sdb
          c)输入 m 显示程序菜单，然后输入 p 检查已存在的分区布局(打印这个设备的分区表)，可以看到该设备已有的分区信息		  
            ==>输入 l 显示可选类型列表(例如 linux 分区类型的ID为83)，然后输入 t 修改分区ID号(只有一个分区的情况下，输入t后再输入新的ID号即可，而多个分区情况下则先进行分区选择，然后再输入新的ID号) 
          d)至此，所有修改只是储存在内存中，而不是在物理设备中。输入 w 会将修改过的分区表写入此设备，再退出即可。若是直接退出，则直接输入 q 即可，设备并未改变。                                  
   
     注意：使用partprobe重载分区也只能是对不同的硬盘才能及时生效。对于同一块硬盘，修改过分区信息后，必须重启系统才能使修改过的分区信息生效。
   
   6)创建新的文件系统：mkfs 创建各种格式的文件系统(在设备分区的基础上面进行)
     例如：$sudo mkfs -t ext3 /dev/sdb1  我们使用“-t” 选项来指定这个“ext3” 系统类型，在此设备上创建一个ext3 文件系统，最后加上我们要格式化的设备分区名称。
	       $sudo mkfs -t vfat /dev/sdb1  指定系统类型为“vfat”，可以重新将该设备格式化为它最初的FAT32文件系统
	 $sudo dmesg | tail 查看文件系统分区情况
      
	 注意：任何时候添加额外的存储设备到系统中时，都可以使用这个分区和格式化的过程
   
   7)fsck 程序：检查文件系统的完整性，同时还能修复受损的文件系统，其成功度依赖于损坏的数量
     例如：检查闪存驱动器之前，我们首先应该卸载该挂载点
	       $umount /dev/sdb 
		   $sudo fsck /dev/sdb
   
   8)dd 程序：把数据块从一个地方复制到另一个地方
        例如：两个相同容量的USB闪存驱动器，需要精确地把第一个驱动器(/dev/sdb)中的内容复制到第二个(/dev/sdc)，可以
		      $dd if=/dev/sdb of=/dev/sdc
   
              若只有一个驱动器连接到计算机上，可以把它的内容复制到一个普通文件中供以后恢复或复制数据
			  $dd if = /dev/sdb of = flash_drive.img
			  
			  制作一张现有CD-ROM的iso映像，该技术也适用于DVD光盘，但是不能用于音频CD。假设该CD设备名称为/dev/cdrom
			  $if = /dev/cdrom of = ubuntu.iso
			  
   9)genisoimage程序：创建一个包含目录内容的 iso 映像文件。首先创建一个目录，这个目录中包含了要包括到此映像中的所有文件，然后执行这个genisoimage 命令来创建映像文件。
         例如：$genisoimage -o cd-rom.iso -R -J ~/cd-rom-files
         其中: -R 表示添加元数据为Rock Ridge 扩展，这允许使用长文件名和POSIX 风格的文件权限。同样地，这个“-J” 选项使Joliet 扩展生效，这样Windows 中就支持长文件名了。		 
			  
  10)我们可以挂载一个映像文件就好像它是一台设备，可以把它连接到文件系统树上
     $mkdir /mnt/iso_image
     $mount -t iso9660 -o loop image.iso /mnt/iso_image
     注意：上述操作需要添加“-o loop”选项来挂载，同时必须带有“-t iso9660”文件系统类型。
           映像文件被挂载之后，可以把它当作，就好像它是一张真正的CD-ROM 或者DVD。当不再需要此映像文件后，记得卸载它	 
			  
  11)wodim程序：可以擦除或清空需要被重使用的可重写入的CD-ROM，需要指定设备名称和清空类型，最小且最快的是“fast”类型
          例如：$woidm dev=/dev/cdrm blank=fast  
			  
                wodim还可以写入镜像，指定光盘设备名和映像文件名
          例如：$wodim dev=/dev/cdrm image.iso				
			  
			    wodim还支持其它选项
		  例如："-v"：详细输出；“-dao”：以 disk-at-once 模式写入光盘
			  
17.网络系统
   1)监测网络、文件传输、远程登录的命令		  
     ping        -发送 ICMP ECHO REQUEST 软件包到网络主机
     traceroute  -打印到一台网络主机的路由数据包	  
     netstat     -打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员
     ftp         -因特网文件传输程序
     wget        -非交互式网络下载器
     ssh         -OpenSSH SSH 客户端（远程登录程序）   
			  
   2)检查和监测网络
     a)连接到网站 linuxcommand.org
       $ping linuxcommand.org 
       注意：一旦启动，ping 命令会持续在特定的时间间隔内（默认是一秒）发送数据包，直到它被中断。
             一个正常工作的网络会报告零个数据包丢失。	   
             一个成功执行的“ping”命令会意味着网络的各个部件（网卡，电缆，路由，网关）都处于正常的工作状态。
			 
	 b)traceroute程序：显示从本地到指定主机要经过的所有“跳数”的网络流量列表。
       例如：$traceroute slashdot.org
       注意：对于那些提供标识信息的路由器，我们能看到它们的主机名，IP 地址和性能数据，这些数据包括三次从本地到此路由器的往返时间样本	   
			 对于那些没有提供标识信息的路由器（由于路由器配置，网络拥塞，防火墙等方面的原因），我们会看到几个星号
			 
	 c)netstat程序：检查各种各样的网络设置和统计数据。
       例如：-ie 选项，可以查看网络设置中的各种特性。
             eth0，是因特网接口；lo，是内部回环网络接口，它是一个虚拟接口，系统用它来“自言自语”。	   
			 UP,BROADCAST,RUNNING,MULTICAST 表示该网络接口已经生效
			 inet addr 表示有效ip地址，对于使用DHCP（动态主机配置协议）的系统，在这个字段中的一个有效IP 地址则证明了DHCP 工作正常。
			 
			 -r 选项，可以看到位于防火墙之内的局域网中，一台客户端计算机的典型路由表。
			 IP 地址以零结尾是指网络，而不是个人主机，所以这个目的地意味着局域网中的任何一台主机。
			 Gateway 是网关（路由器）的名字或IP 地址，用它来连接当前的主机和目的地的网络。若这个字段显示一个星号，则表明不需要网关。
			 default，指的是发往任何表上没有列出的目的地网络的流量。
			 
   3)网络中传输文件
     a)ftp程序：被广泛用来从英特网上下载文件。   
			 
	 b)wget程序：可以从网络和FTP网站上下载数据，不止能下载单个文件或多个文件，甚至整个网站都能下载。	  	 
	   注意：wget 从指定的URL下载文件。wget非常稳定，很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。
	         如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。		  
	   
	   例如：wget http://www.linuxde.net/testfile.zip   下载单个文件并保存在当前目录，下载过程中会显示进度条(包含下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间)。		 
			 
			 wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080  下载并以不同的文件名保存
			 注意：wget默认会以最后一个符号/的后面的字符来命令，对于动态链接的下载通常文件名会不正确(如 wget http://www.linuxde.net/download?id=1 即使下载的文件是zip格式，它仍然以download.php?id=1080名称保存)，因此加上参数 -O 来指定一个文件名。
			 
			 wget --limit-rate=300k http://www.linuxde.net/testfile.zip  wget限速下载
			 
			 wget -c http://www.linuxde.net/testfile.zip 使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。
			 
   4)与远程主机安全通信
     a)SSH=SSH服务器+SSH客户端，其中SSH服务器运行在远端主机上，在端口号22上监听将要到来的连接，而SSH客户端则在本地系统中，用来和远端服务器通信。
	   
	   $ssh remote-sys 连接到远端名为 remote-sys 的主机   
	   
       注意：为了能让系统接受来自远方的连接，就必须安装 OpenSSH-server 软件包，并配置、运行，并且它必须允许在TCP端口号上接收网络连接。
             连接成功后，远端shell会话一直存在，直到用户输入 exit 命令后，则关闭了远程连接

     b)可以使用不同的用户名连接到远程系统
	   例如：如果本地用户“me”，在远端系统中有一个帐号名“bob”，则用户me 能够用bob 帐号登录到远端系统
	         $ ssh bob@remote-sys

     c)OpenSSH软件包含两个程序，可以利用SSH加密通道在网络间复制文件
	   ==>scp(安全复制)，被用来复制文件，与熟悉的cp 程序非常相似。
	      最显著的区别就是源或者目标路径名要以远端主机的名字，后跟一个冒号字符开头

       ==>sftp，它是ftp 程序的安全替代品。

18.查找文件
   1)locate程序：快速搜索路径名数据库，并且输出每个与给定字符串相匹配的文件名，不过只能根据路径名来查找文件。
     例如：locate bin/zip 搜索它的路径名数据库，输出任一个包含字符串“bin/zip”的路径名(如/usr/bin/zip，/usr/bin/zipcloak)
            
     拓展：grep程序：全面搜索正则表达式并把行打印出来，是一种强大的文本搜索工具，可以使用正则表达式搜索文本，并把匹配的行打印出来。
	 
   2)find程序：基于各种属性，搜索一个给定目录(以及它的子目录)，来查找文件。
     a)最简单的使用是搜索一个或多个目录
	   例如：find ~ 输出家目录列表
             find ~ | wc -l 将输出的家目录列表管道到其它程序中，通过wc程序来计算文件的数量
			 
     b)通过添加测试条件，限定搜索对象范围
	   例如：find ~ -type d | wc -l  限制只搜索目录(-type d) 
	   
	   ==>以下为 -type 限制条件：
			   文件类型     描述
				b           块设备文件
				c           字符设备文件
				d           目录
				f           普通文件
				l     .
				符号链接

       ==>还可以根据文件大小和文件名来搜索： -name + 通配符模式(用双引号括起来，阻止shell展开路径名)；-size + 字符串(双引号括起来，内容为 "+" 后面接文件大小，比如 "+1M") 
       例如：find ~ -tyoe f -name "\*.JPG" -size +1M | wc -l  统计所有后缀名为 .JPG，大小为 1M 的普通文件数目    
       注意：-size 测试条件后面的 “+” 表示“大于”指定数的文件，减号表示小于指定数的文件，若没有符号则表示精确匹配。
	         M 表示测量单位是兆字节，以下字符可被用来指定测量单位
			 字符单       位
             b            512 个字节块。如果没有指定单位，则这是默认值。
             c            字节
             w            两个字节的字
             k            千字节(1024 个字节单位)
             M            兆字节(1048576 个字节单位)
             G            千兆字节(1073741824 个字节单位)
	     
	 c)find 程序支持大量不同的测试条件，以下为常见的一些测试条件。
	   测试条件        描述
       -cmin n         匹配的文件和目录的内容或属性最后修改时间正好在n 分钟之前。指定少于n 分钟之前，使用-n，指定多于n 分钟之前，使用+n。
       -cnewer file    匹配的文件和目录的内容或属性最后修改时间早于那些文件。
       -ctime n        匹配的文件和目录的内容和属性最后修改时间在 n*24 小时之前。
       -empty          匹配空文件和目录。
       -group name     匹配的文件和目录属于一个组。组可以用组名或组ID 来表示。
       -iname pattern  就像-name 测试条件，但是不区分大小写。
       -inum n         匹配的文件的inode 号是n。这对于找到某个特殊inode 的所有硬链接很有帮助。
       -mmin n         匹配的文件或目录的内容被修改于n 分钟之前。
       -mtime n        匹配的文件或目录的内容被修改于n\*24 小时之前(即n天前的24小时内被修改过的文件，n=0 表示当前时间)。
       -name pattern   用指定的通配符模式匹配的文件和目录。
       -newer file     匹配的文件和目录的内容早于指定的文件。当编写shell 脚本，做文件备份时，非常有帮助。每次你制作一个备份，更
                       新文件（比如说日志），然后使用find 命令来决定自从上次更新，哪一个文件已经更改了。
       -nouser         匹配的文件和目录不属于一个有效用户。这可以用来查找属于删除帐户的文件或监测攻击行为。
       -nogroup        匹配的文件和目录不属于一个有效的组。
       -perm mode      匹配的文件和目录的权限已经设置为指定的mode。mode可以用八进制或符号表示法。
       -samefile name  相似于-inum 测试条件。匹配和文件name 享有同样inode号的文件。
       -size n         匹配的文件大小为n。
	   -type c         匹配的文件类型是c。
	   -user name      匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户ID 来表示。 
			 
	   注意：在需要数值参数的情况下，可以应用以上讨论的“+”和“-” 符号表示法
		 
     d)操作符：-and，-or，-not ()，用来描述测试条件之间的逻辑关系		 
	   操作符     描述
       -and       如果操作符两边的测试条件都是真，则匹配，可以简写为 -a。注意，若没有使用操作符，则默认使用 -and。
	   -or        若操作符两边的任一个测试条件为真，则匹配。可以简写为-o。
       -not       该运算符表示查找不满足所给条件的文件(例如：find /! -name tmp 查找文件名不是‘tmp’的所有文件)       
       ()         把测试条件和操作符组合起来形成更大的表达式(输入格式为 \( \) ,因为圆括号对于shell 有特殊含义，我们必须转义它们，来阻止shell 解释它们)。
  
       注意：逻辑操作符的另一个特性要重点理解，比如 expr1 -operator expr2 -->在所有情况下，总会执行表达式expr1；然而由操作符来决定是否执行表达式expr2
             执行与否看如下规则：这样做是为了提高性能...
			 expr1 的结果     操作符     expr2 is...
             真               -and       总要执行
             假               -and       从不执行
             真               -or        从不执行
             假               -or        总要执行
	    
		注意：在每个测试和操作之间会默认应用-and 逻辑运算符
		例如：find ~ -type f -name '*.BAK' -print  等效于下面的命令
		      find ~ -type f -and -name '*.BAK' -and -print
		      测试／行为      只有... 的时候，才被执行
              -print          只有-type f and -name ’*.BAK’ 为真的时候
              -name ‘*.BAK’   只有-type f 为真的时候
              -type f         总是被执行，因为它是与-and 关系中的第一个测试／行为。
 
     e)find 命令允许基于搜索结果来执行操作，从而处理输出列表中的某些条目
	   预定义的find命令操作：也即是预定义的行为
	   操作        描述
       -delete     删除当前匹配的文件。
       -ls         对匹配的文件执行等同的ls -dils 命令。并将结果发送到标准输出。
       -print      把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是默认操作。
       -quit       一旦找到一个匹配，退出。  
	   
     f)除了预定义的行为，还可以唤醒随意的命令
       -->通过 -exec 行为：-exec command {};
          其中，command是一个命令的名字，{}是当前路径名的符号表示，分号是要求的界定符(表明命令结束)。注意 {} 和 ；都要用单引号括起来('{}',';')。	
          因为因为花括号和分号对于shell 有特殊含义，所以它们必须被引起来或被转义。
		  
		  例如：-exec rm '{}' ';'  就等效于前面的 -delete 行为
        	  
	   -->还可以交互式地执行一个用户定义的行为，使用 -ok 代替 -exec，在执行每个指定的命令之前，均会提示用户
	   
	   注意：当使用 -exec 行为时，每找到一个匹配的文件，它就会启动一个新的指定命令的实例(例如 ls -l file1   ls -l file2 ...)。
	         而我们更喜欢 le -l file1 file2，这样就导致命令只被执行一次而不是多次，如此便提高了命令的执行效率。 
	      -->解决方法1：通过把末尾的分号改为加号(不用单引号括了)，就激活了find 命令的一个功能，把搜索结果结合为一个参数列表，然后执行一次所期望的命令
	             例如：find ~ -type f -name 'foo*' -exec ls -l '{}' ';'   改为
				       find ~ -type f -name 'foo*' -exec ls -l '{}' + 
	   
	      -->解决方法2：xargs 命令会执行一个有趣的函数，它从标准输入接受输入，并把输入转换为一个特定命令的参数列表。
	              例如：find ~ -type f -name 'foo\*' -print | xargs ls -l
	                    这里我们看到find 命令的输出被管道到xargs 命令，反过来，xargs 会为ls 命令构建参数列表，然后执行ls 命令。
	   
	   拓展：[me@linuxbox ~]$ mkdir -p playground/dir-{00{1..9},0{10..99},100}
             [me@linuxbox ~]$ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
	         以上两行可以创建了一个包含一百个子目录，每个子目录中包含了26 个空文件的操练场
			 
	         [me@linuxbox ~]$ find playground -type f -name 'file-A' 
			 输出所有100个 file-A 文件，后面加上 | wc -l 可以统计file-A文件个数
			 注意：不同于ls 命令，find 命令的输出结果是无序的，其顺序由存储设备的布局决定
	   
	      ==>touch程序：被用来设置或更新文件的访问，更改，和修改时间，倘若一个文件名参数是一个不存在的文件，则会创建一个空文件。
	         [me@linuxbox ~]$ touch playground/timestamp  
			 创建一个参考文件，将与其比较修改时间
	   
	      ==>stat程序：ls程序的强化版本，会展示系统对于某个文件及其属性所能了解到的所有信息
		     [me@linuxbox ~]$ stat playground/timestamp
	   
	        [me@linuxbox ~]$ find playground -type f -name 'file-B' -exec touch '{}' ';'
			更新所有名为“fiel-B”文件
	   
	        [me@linuxbox ~]$ find playground -type f -newer playground/timestamp
			使用find命令来识别已更新的文件，通过把所有文件与参考文件timestamp做比较
	     ==>-newer程序：测试条件，识别新于后面参考文件的文件(也即是后于参考文件touch的文件)
	        
	        [me@linuxbox ~]$ find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)
	        检查操练场中所有的100个目录以及2600个文件以及操练场本身以及timestamp文件(2702个)的权限是否正确(结果全部输出，没一个正确)
			
            [me@linuxbox ~]$ find playground \( -type f -not -perm 0600 -exec chmod 0600 '{}' ';' \)
            -or \( -type d -not -perm 0711 -exec chmod 0700 '{}' ';' \)
            给上述命令行添加自定义行为，为操练场中的文件和目录赋予新的权限(当然咯，我们可以把上述一个命令拆分成两个，一个操作目录，一个操作文件) 
 
       g)选项：用来控制find程序的搜索范围，当构建find表达式时，它们可能被其它的测试条件和行为包含
	     选项             描述
         -depth           指导 find 程序先处理目录中的文件，再处理目录自身。当指定-delete 行为时，会自动应用这个选项。
         -maxdepth levels 当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数
         -mindepth levels 在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。
         -mount           指导 find 程序不要搜索挂载到其它文件系统上的目录。
			 
19.归档和备份
   几个常用的管理文件集合的程序：
   ==>压缩程序    
	   • gzip –压缩或者展开文件
       • bzip2 –块排序文件压缩器 
   ==>归档程序
       • tar –磁带打包工具   
	   • zip –打包和压缩文件
   ==>文件同步程序
       • rsync – Remote file and directory synchronization
       • rsync –同步远端文件和目录
	
   1)压缩文件：就是一个删除冗余数据的过程
     压缩算法：分为无损压缩(保留了原始文件的所有数据)和有损压缩(执行压缩操作时会删除数据，允许更大的压缩，例如JPEG文件和MP3文件)   
	 注意：压缩算法是通过数学技巧来执行压缩任务的
	 
    ==>gzip程序：压缩一个或多个文件 (原文件的压缩版会替代原始文件)
	   gunzip程序：用来把压缩文件复原为没有被压缩的文件(会保留相同的权限和时间戳)
	   注意：gunzip程序解压压缩gzip文件(拓展名为 .gz)，并不用指定它，只要指定的文件名和现有的未压缩文件不冲突即可(不用指定 .gz)
	         zcat程序 = 带有 -c 选项的 gunzip 命令。
	   
	   选项：
	   选项    说明
       -c      把输出写入到标准输出，并且***保留原始文件***。也有可能用 --stdout 和 --to-stdout 选项来指定。
       -d      解压缩。正如gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定.
       -f      强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选项来指定。
       -h      显示用法信息。也可用--help 选项来指定。
       -l      列出每个被压缩文件的压缩数据。也可用--list 选项。
       -r      若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用 --recursive 选项来指定。
       -t      测试压缩文件的完整性(注意先得是压缩文件)。也可用--test 选项来指定。
       -v      显示压缩过程中的信息(显示gzip程序执行信息)。也可用--verbose 选项来指定。
       -number 设置压缩指数。number 是一个在1（最快，最小压缩）到 9（最慢，最大压缩）之间的整数。数值1 和9 也可以各自用--fast 和--best 选项来表示。默认值是整数6。
	   
    ==>bzip2程序：使用了不同的压缩算法，舍弃了压缩速度，而实现了更高的压缩级别，使用和gzip一样，也为无损压缩，其拓展名为.bz2。
        选项：上述除了 -r 之外的所有选项，bzip2全部支持。
              此外， -number 压缩级别选项对于 bzip2 程序来说，有少许不同的含义。		
	    
		注意：同样也有 bunzip2 程序和 bzcat 程序
	          
	    Don’t Be Compressive Compulsive
	
   2)归档文件：就是搜集许多文件，并把它们捆绑成一个大文件的过程。
               一个 tar 包可以由一组独立的文件，一个或者多个目录，或者两者混合体组成。
	 
    ==>tar程序：制作磁盘备份的工具，也适用于其它的存储设备，后缀名 .tar(普通的tar包)，.tgz(被gzip程序压缩过的tar包)
          语法：tar mode[options] pathname...
		  
		  其中mode是指以下操作模式：
		  模式     说明
          c        为文件和／或目录列表创建归档文件。
          x        抽取归档文件(然后在另外一个地方创建一个精确的原始文件的副本)。
          r        追加具体的路径到归档文件的末尾。
          t        列出归档文件的内容。
       
        例如：[me@linuxbox ~]$ tar cf playground.tar playground 
          	  该命令创建了一个名为 playground.tar 的 tar 包，其包含整个 playground 目录层次结构，其中模式c和选项f，创建的tar文件使用该选项指定的文件名。
			  模式和选项可以写在一起，而且不需要开头的短横线(注意必须先指定模式，再指定选项)	 
	                                                                                                    
              [me@linuxbox ~]$ tar tf playground.tar
              列出归档文件的内容(为了得到更详细的信息，我们可以用 tvf) 			  
                     
              [me@linuxbox foo]$ tar xf ../playground.tar
			  提取归档文件到指定目录下
			  
        注意：tar使用的是相对路径名，而不是绝对路径名。当我们创建归档文件时，tar 命令会简单地删除路径名开头的斜杠。                     
              当我们使用绝对路径名创建一个归档文件后，再抽取该归档文件(xf)，它会相对于我们当前的工作目录(而不是相对于 root 目录)重新创建 /home/me/palyground。
			  这样允许我们抽取文档到任意位置，而不是强制地把抽取的文件放置到原始目录下。			  
			  
        注意：当按下回车键后，~/playground 会展开成/home/me/playground，所以我们将会得到一个绝对路径名		

        实例：复制家目录及其内容到另一个系统中，利用大容量的USB硬盘作为传输工具(假设硬盘自动挂载带/media目录下，假设硬盘中有个名为BigDisk的逻辑卷)
		      sudo tar cf /meida/BigDisk/home.tar /home   将home目录及其内容归档为硬盘中的home.tar文件
			  cd /  由于归档文件中的路径名都是相对的，所以首先必须更改目录到更目录下，如此抽取的文件路径就相对于根目录了
			  sudo tar xf /media/BigDisk/home.tar  将硬盘插到另一个计算机上，再一次该硬盘被挂载到了/media/BigDisk目录下，开始抽取归档文件
			  
			  注意：抽取归档文件时，我们可以限制抽取的内容
			        tar xf archive.tar pathname  通过给命令添加末尾的路径名，tar命令就只会恢复指定的文件，我们可以指定多个路径名。
                                                 注意路径名必须是完全精确的相对路径名，而且指定路径名不支持通配。 
 		
        用法：a) tar 命令经常结合find 命令一起来制作归档文件		
		         [me@linuxbox ~]$ find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'
			     ==>find命令来匹配playground目录中的所有名为file-A的文件，然后用 -exec 程序来唤醒带有追加模式(r)的tar程序，把匹配的文件添加到归档文件playground.tar中。
              		
                 tar 命令也可以利用标准输出和输入
			     $find playground -name 'file-A' | tar cf - --files-from=- | gzip > playground.tgz
                 ==>find程序产生一个匹配文件列表，然后把它管道到 tar 程序中。如果指定了文件名 “-”，则其被看作是标准输入或输出(使用“-”表示标准输入/标准输出是个惯例)。
			        --file-from 选项（也可以用 -T 来指定）导致 tar 命令从一个文件而不是命令行来读入它的路径名列表。
                    这个由tar 命令产生的归档文件被管道到gzip 命令中，然后创建了压缩归档文件playground.tgz
                 注意：如今的GUN版本的 tar 命令，都是直接支持 gzip 和 bzip2 压缩，各自使用 z 和 j 选项。  
			           $find playground -name 'file-A' | tar czf playground.tgz -T -
					   制作压缩归档文件(由 gzip 压缩)
					   $find playground -name 'file-A' | tar cjf playground.tbz -T -
                       制作压缩归档文件(由 bzip2 压缩)

              b) tar程序与标准输入和输出的使用，还涉及到在系统之间经过网络来传输文件
                 $mkdir remote-stuff     在本地系统创建一个目录用来存放从远端系统传过来的目录
                 $cd remote-stuff
				 $ssh localhost 'tar cf - playground.tgz' | tar xf -   连接远端系统，将远端文件归档到标准输出，然后在近端系统上提取该归档文件到当前目录(ls 检查看传(复制)过来了没)

    ==>zip程序：既是压缩工具，又是打包工具，Windows 读取和写入.zip文件(然而，linux中 gzip 是主要的压缩工具，而 bzip2 位居第二)。
	      使用：zip options zipfile file...
		  
		  实例：[me@linuxbox ~]$ zip -r playground.zip playground
		        必须包含-r 选项，要不然只有playground 目录（没有任何它的内容）被存储。
         		显示信息：...adding: playground/dir-020/file-Z (stored 0%)...
                          这些信息显示了添加到文件包中每个文件的状态				
       zip存储：zip会使用两种存储方法之一来添加文件到文件包中，要么会“store”没有压缩的文件，要么会“deflate”文件，执行压缩操作(在存储方法之后显示的数值表明压缩量)      
      
	   注意：对于zip 命令（与tar 命令相反）要注意一点，就是如果指定了一个已经存在的文件包，其被更新而不是被替代(这意味着会保留此文件包，但会添加新文件，同时替换匹配的文件)	   
	   
	      用法：a)zip命令也可以利用标准输入输出(通过 -@ 选项，可以将一系列的文件名管道到 zip 命令)
	              [me@linuxbox ~]$ find playground -name "file-A" | zip -@ file-A.zip
				  使用find 命令产生一系列与“file-A”相匹配的文件列表，并且把此列表管道到zip 命令，然后创建包含所选文件的文件包file-A.zip
				
				b)zip命令也支持把它的输出写到标准输出，但是它的使用是有限的
				
    ==>unzip程序：直接抽取一个zip内容，注意unzip程序不接受标准输入，但是zip程序接受标准输入(因此可被用来压缩其它程序的输出)
	        实例： unzip playground.zip  解压后若该目录下有相同的文件存在，系统会提示你是否进行替换操作
         
		    使用：可以列出文件或者有选择地从一个zip 文件包中抽取文件，只要给unzip 命令指定文件名
                  [me@linuxbox ~]$ unzip -l playground.zip playground/dir-87/file-Z
                  注意：-l选项导致unzip程序只是列出了文件包中的内容，并没有抽取文件

                  unzip程序允许把它的输出发送到标准输出，需要指定选项 -p
				  [me@linuxbox ~]$ unzip -p ls-etc.zip | less

   3)同步文件和目录
     rsync程序：能快速检测两个目录之间的差异，执行最小量的复制达到目录间的同步(只有检查到更改才会复制更新了的文件部分)   
          使用： rsync options source destination
		  选项：source 和 destination 选自下面内容
		        • 一个本地文件或目录
				• 一个远端文件或目录，以[user@]host:path 的形式存在
				• 一个远端rsync 服务器，由rsync://[user@]host[:port]/path 指定
		  注意：rsync不支持远端到远端的复制，其中 source 和 destination 两者之一必是本地文件       

          实例：$rsync -av playground foo 
		        在foo目录下制作一个 playground 目录的镜像，其中 -a 选项是递归和保护文件属性，-v 选项是冗余输出

          实例：假设一个硬盘挂载在一个 /media/BigDisk 目录下，可以执行一个有用的系统备份
		        a)首先在外部硬盘上创建一个目录，名为 /backup
				  $mkdir /media/BigDisk/backup
				b)然后把 /etc,/home,/usr/local目录从我们的系统中复制到假设的存储设备中
				  $sudo rsync -av --delete /etc/home /usr/local /media/BigDisk/backup
				  注意：包含了 –delete 这个选项，来删除可能在备份设备中已经存在但却不再存在于源设备中的文件
          
		  作用：挂载外部驱动器，运行 rsync 命令，不断重复这个过程，是一个不错的（虽然不理想）方式来保存少量的系统备份文件
		  
		  简化：别名对这个需要反复进行的操作很有帮助，创建一个别名并将它添加进入 .bashrc 文件中去
		        alias bcakup='sudo rsync -av --delete /etc/home /usr/local /media/BigDisk/backup'
		        现在要做的就是连接一个外部驱动器，然后运行 backup 命令来完成工作
		  
	 ==>应用
        a)rsync程序被用来在网络间复制文件(rsync中的r象征着remote)，复制有两种方法
          ==>方法1：要求远程系统安装了rsync程序以及远程shell程序，比如ssh		
		      实例：[me@linuxbox ~]$ sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup
                    将远程系统替代一个外部驱动器，来执行备份操作。其中，--rsh=ssh选项，指示 rsync 使用 ssh 程序作为它的远程 shell。
                    如此我们便可以使用一个ssh加密通道，把数据安全传输到远程主机中。同时，我们在目标路径名前加上了主机名字来指定远端主机。

          ==>方法2：使用 rsync 服务器，它可以被配置为一个守护进程，监听即将到来的同步请求。

20.正则表达式：一种符号表示法，被用来识别文本模式
   1)grep程序：会在文本中查找一个指定的正则表达式，并把匹配行输出到标准输出
         用法：grep [options] regex [file...]
     
	 grep选项：选项        描述
               -i          忽略大小写。不会区分大小写字符。也可用 --ignore-case 来指定
			   -v          不匹配。通常， grep 程序会打印包含匹配项的文本行。这个选项导致 grep 程序只会不包含匹配项的文本行。也可用--invert-match 来指定。
               -c          打印匹配的数量（或者是不匹配的数目，若指定了 -v 选项），而不是文本行本身。也可用 --count 选项来指定。
               -l          打印包含匹配项的文件名，而不是文本行本身，也可用--files-with-matches 选项来指定。
               -L          相似于 -l 选项，但是只是打印***不包含匹配项的文件名***。也可用 --files-without-match 来指定。
               -n          在每个匹配行之前打印出其位于文件中的相应行号。也可用--line-number 选项来指定。
               -h          应用于多文件搜索，不输出文件名，只输出匹配文件内容。也可用 --no-filename选项来指定。	
		  
   2)元字符和文本
     原义字符：例如 grep bzip dirlist*.txt 中的字符串“bzip”，它们匹配自身(意味着至少包含4个字符，按照b、z、i、p顺序，字符之间无其它字符)   
	   元字符：^ $ . [ ] { } - ? * + ( ) | \，由于当shell执行展开时，许多正则表达式元字符也是对shell有特殊含义的字符，因此当在命令行中传递包含
               元字符的正则表达式时，把元字符用引号引起来至关重要，阻止shell展开它们	   
		  
   3)任何字符：圆点字符(.)，其被用来匹配任意字符(对应位置)。
         注意：当查找包含正则表达式“.zip”的文本行时，不会找到 zip 程序，因为正则表达式中包含的圆点字符把所要求的匹配项的长度增加到了四个字符，而字符串“zip”只包含三个字符，故而不匹配。
		       而一些文件拓展名是“.zip”的也会匹配，因为正则表达式中的圆点“.”被看作是任意字符
			   
   4)锚点：在正则表达式中，插入符号(^表示行首)和美元符号($表示行尾)被看作是锚点，规定对应位置的匹配。
           这意味着正则表达式只有在本行的开头或者末尾被找到时，才算发生一次匹配。   
	 实例：$grep -h '^zip$' dirlist*.txt
	       我们搜索行首行尾同时包含有字符串“zip”的匹配行
	 注意：注意正则表达式‘ˆ$’（行首和行尾之间没有字符）会匹配空行	   
	 
     拓展：Linux系统带有一本英文字典，在 /usr/share/dict 目录，我们可以利用正则表达式搜索其中任何单词
	       $ grep -i '^..j.r$' /usr/share/dict/words
		   查找字典中词长为5，第三个字母为j，最后一个字母为r的单词
     	
   5)中括号：能够从一个指定的字符集合中匹配某一个字符(该集合有许多字符，匹配一个即可)，当然也可以匹配多个(即相当于不加中括号的情况，也即被解释为元字符的情况)。	  
	   注意：一个字符集合可能包含任意多个字符，并且元字符被放置到中括号里面后便失去了它们的特殊含义。两种情况下会在中括号中使用元字符并有着不同的含义，第一种是插入字符 ^ (用来表示否定)，
	         第二种是连字字符 - (用来表示一个字符区域)
		    
     ==>否定：[^...]，中括号中第一个字符为插入字符，则后面字符被看作是不会在给定字符位置出现的字符集合
        注意：一个否定的字符集仍然在给定位置要求一个字符，但是这个字符必须不是否定字符集的成员  
		     
     ==>传统的字符区域：可以通过一个三字符区域，缩写26个字母，任何字符的区域都可以按照这种方式来表达，包括多区域
                  实例：'^[A-Z]' 在搜索对象中寻找每个以大写字母开头的文件(正则表达式中如此输入26个字母，通过使用一个三字符区域，我们能够缩写 26 个字母)	  
		                 
		          注意：使连字符成为表达式中的第一个字符，如此就在正则表达式中包含一个连字符
                        $grep -h '[-]' dirlist*.txt  匹配所有包含连字符“-”的文件内容				  
		  
   6)$ ls /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*	我们将会得到以大写字母开头的文件名
     $ ls /usr/sbin/[A-Z]*  我们却得到了以A-Z以及b-z字母开头的所有文件
     解释：ASCII码字母排序规则是ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz，而正常的字典顺序是aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ。通过 $echo $LANG 查看我们系统的语言设置，我们将会
           看到输出结果为 en-US、UTF-8，由于此设置，符合POSIX的应用程序将会使用字典排列顺序而不是 ASCII 顺序。	 
		  
     解决：POSIX 标准包含了大量的字符集，其提供了有用的字符区域
	       字符集     说明 
		   [:alnum:]  字母数字字符。在ASCII 中，等价于：[A-Za-z0-9]
		   [:upper:]  大写字母。
		   [:alnum:]  字母数字字符。在ASCII 中，等价于：[A-Za-z0-9]
           [:word:]   与[:alnum:] 相同, 但增加了下划线字符。
           [:alpha:]  字母字符。在ASCII 中，等价于：[A-Za-z]
           [:blank:]  包含空格和tab 字符。
           [:cntrl:]  ASCII 的控制码。包含了0 到31，和127 的ASCII 字符。
           [:digit:]  数字0 到9
           [:graph:]  可视字符。在ASCII 中，它包含33 到126 的字符。
           [:lower:]  小写字母。
           [:punct:]  标点符号字符。在ASCII 中，等价于：
           [:print:]  可打印的字符。在[:graph:] 中的所有字符，再加上空格字符。
           [:space:]  空白字符，包括空格，tab，回车，换行，vertical tab, 和 form feed. 在ASCII 中，等价于：[ \t\r\n\v\f]
           [:upper:]  大写字母。
           [:xdigit:] 用来表示十六进制数字的字符。在ASCII 中，等价于：[0-9A-Fa-f]
		  
		  $ ls /usr/sbin/[[:upper:]]*  即可输出大写字母开头的所有文件(并非正则表达式，而是shell正在执行路径名展开操作)
		    使用字符集注意这里是两个中括号
		 
	 注意：环境变量LANG值决定你的系统正在使用的字符排列规则，它包含了语种和字符集，该变量可通过 locale 程序查看
           $export LANG=POSIX  将LANG变量设置为POSIX，更改locale，使其使用传统的 Unix 行为 
	
	 拓展：什么是posix(可移植操作系统接口)
           在网上查到对于posix的介绍，来自《Linux内核设计与实现（第2版）》的第5章，就这部分来看，这本书估计不错。一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核 提供的系统调用对应。
		   一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系 统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。
           在Unix世界中，最流行的应用编程接口是基于POSIX标准的。从纯技术的角度看，POSIX是由IEEE的一组标准组成，其目标是提供一套大体上基于Unix的可移植操作系统标准。Linux是与POSIX兼容的。POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而
		   定义的API函数和系统调用之间有着直接关 系。实际上，POSIX标准就是仿照早期Unix系统的界面建立的。另一方面，许多操作系统，像Windows NT，尽管和Unix没有什么关系，也提供了与POSIX兼容的库。Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如图5-1所示。
		   所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C库提供了POSIX的 绝大部分API。
           从程序员的角度看，系统调用无关紧要；他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。
           简单总结：完成同一功能，不同内核提供的系统调用（也就是一个函数）是不同的，例如创建进程，linux下是fork函数，windows下是creatprocess函数。好，我现在在linux下写一个程序，用到fork函数，那么这个程序该怎么往windows上移植？我需要把源代码里的fork通通改成creatprocess，
		   然后重新编译...posix标准的出现就是为了解决这个问题。linux和windows都要实现基本的posix标准，linux把fork函数封装成posix_fork（随便说的），windows把creatprocess函数也封装成posix_fork，都声明在unistd.h里。这样，程序员编写普通应用时候，只用包含unistd.h，调用posix_fork函数，程序就在源代码级别可移植了。
	
	 注意：POSIX将正则表达式分为：BRE(基本正则表达式)和ERE(拓展的正则表达式)，二者区别在于BRE可以辨别以下元字符：^ $ 、[] *，然后其它所有字符被认为是文本字符。而ERE添加了以下元字符：( ) { } + |
	       在BRE 中，字符“(”，“)”，“{”，和“}”用反斜杠转义后，被看作是元字符, 相反在ERE 中，在任意元字符之前加上反斜杠会导致其被看作是一个文本字符。
	 
   7)alternation 选项(用 -E 表示，用竖杠线 | 为标记)：交替，允许从***一系列表达式(或来自标准输入，或来自后面参数文件等)***之间选择匹配项的实用程序，是ERE的一个特性	
	 实例：$ echo "AAA" | grep -E 'AAA|BBB'     ==>输出 AAA 
	       $ echo "AAA" | grep -E 'AAA|BBB'     ==>输出 BBB
		   $ echo "AAA" | grep -E 'AAA|BBB'     ==>啥也不输出
	 注意：可以用 egrep 程序代替上面的命令(-E)，locate + --regex 也可以代替上面的命令(使用了正则表达式)
	
   8)限定符
     a) ？ 匹配零个或一个元素，意味着使前面的元素可有可无 
        $ echo "(555) 123-4567" | grep -E '^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]$'	
        圆括号后面加了一个问号，表示这个圆括号可能会被匹配零次或者一次(也即可有可无)		
	
	 b) * 匹配零个或多个元素(前面的元素)
	    $ echo "This works." | grep -E '[[:upper:]][[:upper:][:lower:] ]*\.'
		注意第二个中括号最后面是一个空格，圆点必须加上反斜杠转义才能被认为是圆点。*的意思是前面中括号中的表达式可以出现任意多个，也即任意数目的大写和小写字母和空格。
	
	 c) + 匹配一个或多个元素，它要求前面的元素至少出现一次匹配
	    $ echo "This that" | grep -E '^([[:alpha:]]+ ?)+$'
		靠头和结尾必须至少有一个表达式，其至全部是字母(至少出现一次)，可能包含有零个或一个空格，也即匹配那些由一个或多个字母字符组构成的文本行，字母字符之间由单个空格分开。
		
	 d) { and } 匹配特定个数的元素，被用来表达要求匹配的最小和最大数目，其有如下限定词
	    限定符   意思
        n        匹配前面的元素，如果它确切地出现了n 次。
        n,m      匹配前面的元素，如果它至少出现了n 次，但是不多于m次。
        n,       匹配前面的元素，如果它出现了n 次或多于n 次。
        ,m       匹配前面的元素，如果它出现的次数不多于m 次。
	
	   例如：^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$ 可以简化为
	         ^\(?[0-9]{3}\)? [0-9]{3}-[0-9]{4}$
	
   9)应用
     a)创建一个包含10个号码的名为 phonelist.txt 的文件，每个号码格式为：(xxx) xxx-xxxx
       $for i in {1..10}; do echo "(${RANDOM:0:3}) ${RANDOM:0:3}-${RANDOM:0:4}" >> phonelist.txt; done
	   注意：这样生成的号码一些会是残缺不全的，可以通过 grep+正则表达式 来搜索这些号码并显示在屏幕上
	 
	   $grep -Ev '^\([0-9]{3}\) [0-9]{3}-[0-9]{4}' phonelist.txt
	    这里是使用-v 选项来产生相反的匹配，输出那些不匹配指定表达式的文本行
	    注意：这个表达式自身的两端都包含定位点（锚）元字符(^ $)，是为了确保这个号码的两端没有多余的字符
	 
	 b)用find查找简陋的文件名
	   ==>find 和 grep 的区别
	      当某一行包含的字符串匹配上了一个表达式的时候，grep 命令会打印出这一行，然而find 命令要求路径名精确地匹配这个正则表达式
	      例如：$find . -regex '.*[^-\_./0-9a-zA-Z].*'
                扫描发现包含空格和其它潜在不规范字符的路径名
				注意：由于要精确地匹配整个路径名，所以我们在表达式的两端使用了.*，来匹配零个或多个字符。
	                  在中括号中使用元字符之插入字符(^)是表示否定含义的，因此表达式中间使用了否定的中括号表达式，其包含了我们一系列可接受
					  的路径名字符([^ 表否定])。同时，注意find使用正则表达式的格式(添上 -regex 选项)。
	              
	 c)用locate查找文件：locate程序支持基本的(--regexp选项)和拓展的(--regex选项)正则表达式
	   例如：$locate --regex 'bin/(bz|gz|zip)'  找到bin目录下所有开头字母是bz或gz或zip的文件
	 
	 d)在less和vim中查找文本
	   less 和vim 两者享有相同的文本查找方法。按下/按键，然后输入正则表达式，来执行搜索任务(不支持类似于 -v 选项，输入即所查)
	   例如：在less中  /^\([0-9]{3}\) [0-9]{3}-[0-9]{4}$
	         在vim中   /([0-9]\{3\}) [0-9]\{3\}-[0-9]\{4\}
	   注意：vim 支持基本的正则表达式，但是在拓展表达式中，很多被认为是元字符的字符在基本的表达式中被看作是文本字符。只有用反斜杠把它们转义之后，才可以被看作
	         是元字符
	    
	   拓展：:hlsearch 激活搜索高亮功能
	
	总结：查找手册页，可以找到许多正则表达式的使用实例  
	      $ cd /usr/share/man/man1
		  $ zgrep -E1 'regex | regular expression' *.gz
	      输出一个包含字符串“regex”或者“regular expression”的文件列表
		  
		  注意：这个zgrep 程序是grep 的前端，允许grep 来读取压缩文件。
	    
21.文本处理
   1)常见处理文本程序
     • cat    –连接文件并且打印到标准输出   
	 • sort   –给文本行排序
	 • uniq   –报告或者省略重复行
	 • cut    –从每行中删除文本区域
	 • paste  –合并文件文本行
	 • join   –基于某个共享字段来联合两个文件的文本行
	 • comm   –逐行比较两个有序的文件
	 • diff   –逐行比较文件
	 • patch  –给原始文件打补丁
     • tr     –翻译或删除字符
	 • sed    –用于筛选和转换文本的流编辑器
	 • aspell –交互式拼写检查器
	
   2)一些命令除了接受命令行参数之外，还能够接受标准输入
     ==>cat程序：作为一个简单的文字处理器，可以查看文本中的非打印字符
	    $cat > foo.txt
		   The quick brown fox jumped over the lazy dog.
	    在文本开头输入一个 tab 字符，文件末尾输入几个空格
		输入结束后。按下Enter 键来结束这一行，然后按下组合键Ctrl-d，来指示cat 程序，我们已经到达文件末尾了。
	
	    $cat -A foo.txt 
		使用 -A 选项显示这个文本，可以看到 tab 字符由 ^I 表示，意思是 “Control-I”。$ 字符出现在文本行真正的结尾处(算了空格啊)，表明文本包含了末尾的空格。
	
	    注意：cat程序也包含用来修改文本的选项，-n 给文本行添加行号，-s 禁止输出多个空白行
	          cat foo.txt 输出foo.txt文本文件(标准输入为后面的文本文件参数，标准输出到屏幕)，而 cat > foo.txt cat接受来自键盘的标准输入，然后将结果送到标准输出，并将标准输出重定向为foo.txt文件。
			  
	 ==>sort程序：对标准输入内容或命令行中指定的一个或多个文件进行排序(排的是文件内容)，然后把排序结果送往标准输出。排序标准，小写在前大写在后。
        
        $sort file1.txt file2.txt file3.txt > final_sorted_list.txt
        sort可以接受命令行中的多个文件作为参数，所以可以将多个文件合并称为一个有序的文件		

	    sort选项：选项 长选项                  描述
                  -b   --ignore-leading-blanks 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致sort 程序忽略每行开头的空格，从第一个非空白字符开始排序。
                  -f   --ignore-case           让排序不区分大小写。
                  -n   --numeric-sort          基于字符串的长度来排序。使用此选项允许根据数字值执行排序，而不是字母值(前提是数值必须出现在每行的开头)。
                  -r   --reverse               按相反顺序排序。结果按照降序排列，而不是升序。
                  -k   --key=field1[,field2]   对从field1 到field2 之间的字符排序，而不是整个文本行。也即是，规定sort使用哪个字段作为排序的关键值。
                  -m   --merge                 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。
                  -o   --output=file           把排好序的输出结果发送到文件，而不是标准输出。
                  -t   --field-separator=char  定义域分隔字符。默认情况下，域由空格或制表符分隔。
	    例如：$du -s /usr/share/\* | head    
		      du 命令可以确定最大的磁盘空间用户，将结果管道给 head 可以限制输出结果为10行
	          
			  对du的标准输出进行排序操作的改进
	          $du -s /usr/share/\* | sort -nr | head
			  输出10个最大的空间消费者
	 
	          $ ls -l /usr/bin | head
			    ls会按照文件大小来进行排序
	          $ ls -l /usr/bin | sort -nr -k 5 | head
			    我们不管ls的排序，重新用sort再来排一次。 -nr 表示执行相反的数值排序， -k 5 表示从第5个字段开始排序(刚好是数字)。
			  注意：sort -n 可以根据数值进行排序是因为数值刚好在每一行文本的开头呢
			  
	    sort定义字段：空白字符(空格和制表符)被当作字段间的界定符，当执行排序时，界定符会被包含进前一个字段当中(空格少的排在前面)。
	    
		==>-k 选项
			sort支持指定多关键值排序：sort程序允许多个-k选项的实例
				  $ sort --key=1,1 --key=2n distros.txt   等价于短格式
				  $ sort -k 1,1 -k 2n distros.txt
				  第一个关键字指定区域为第一个字段(1,1指定了区域，始于该字段也止于该字段)，第二个关键字指定排序键值为第二个字段，n表示按照数值排序(由于第二个关键字并没有指定区域，故而该键值始于指定字段，一直扩展到行尾)。
				  
			注意：一个关键字可能包含一个字段区域，如果没有指定区域(如上述1,1便指定了)，那么sort程序会使用一个键值，其始于指定的字段，一直拓展到行尾。
				  一个选项字母可能被包含在一个键值说明符的末尾，其用来指定排序的种类(例如：b 忽略开头的空格，n 数值排序，r 逆向排序)。
	
	        -k选项：允许在字段中指定偏移量，因而我们可以在字段中定义键值
	              $ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt   
	              通过 -k 3.7，我们指定sort的排序键值为 始于第三个字段第七个字符，对应年的开头，然后顺着比下去(n 表示通过数值大小进行排序)。
	  
	        注意：关键字指定的排序键值有先后顺序，先出现的排序键值优先，排不出后再通过第二个排序键值来进行排序，以此类推。
	
	        字段界定符：一些字段不会以空格或者tab键来作为界定符，而是冒号。
			            可以通过选项 -t来指定界定符，即 $sort -t ':' -k 7 /etc/passwd | head
			
	 ==>uniq程序：当给定一个排好序的文件（包括标准输出），uniq 会删除任意重复行，并且把结果发送到标准输出。
                  一般和sort程序一块使用，清理重复输出。
            注意：uniq 程序能完成任务，其输入必须是排好序的数据，因为 uniq 只会删除相邻的重复行。				  
			
			实例：$cat > foo.txt
                   a
                   b
                   c				   
			       a
                   b
                   c     然后，$uniq foo.txt 发现输出结果和原来无异
			
			选项：
			选项     说明
            -c       输出所有的重复行，并且每行开头显示重复的次数。
            -d       只输出重复行，而不是特有的文本行。
            -f n     忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort 程序中的空格分隔符；然而，不同于 sort 程序， uniq 没有选项来设置备用的字段分隔符。
            -i       在比较文本行的时候忽略大小写。
            -s n     跳过（忽略）每行开头的 n 个字符。
            -u       只是输出独有的文本行。这是默认的。
			
   3)切片和切块
     ==>cut程序：被用来从文本行中抽取文本，并把其输出到标准输出，它能够接受多个文件参数或者标准输入           
		   选项：选项          说明
                 -c char_list  从文本行中抽取由 char_list 定义的文本。这个列表可能由一个或多个逗号分隔开的数值区间组成。
                 -f field_list 从文本行中抽取一个或多个由 field_list 定义的字段(如同上面的 -k 选项一样，指定一个字段区域)。这个列表可能包括一个或多个字段，或由逗号分隔开的字段区间。
                 -d delim char 当指定 -f 选项之后，使用 delim_char 做为字段分隔符。默认情况下，字段之间必须由单个 tab 字符分隔开。
                 --complement  抽取整个文本行，除了那些由 -c 和／或 -f 选项指定的文本
		   
		   例如：$cut -f 3 dirtros.txt   其中distros.txt文本中由tab作为界定符
		         一个由tab分离的文件，每行不太可能包含一样的字符数，因此cut最好是抽取字段(计算每行中字符位置有点困难)
			    
				 $ cut -f 3 distros.txt | cut -c 7-10
				 由于日期长度相同，因此我们可以用cut来抽取字符(或一个区域内的字符)，注意这里抽取对应区域字符的表示(7-10)
				 注意：cut抽取字符不影响原文件内容
			
			    $expand distros.txt | cut -c 23-
				使用expand来处理文本，我们可以直接用 cut -c 命令来从文件中抽取任意区间内的字符
		   
		   拓展：expand，把文件中的界定符 tab 用空格代替。它既可以接受一个或多个文件参数，也可以接受标准输入，并且把修改过的文本送到标准输出
			
		   例如：$cut -d ':' -f 1 /etc/passwd | head
                 指定 ：作为字段分隔符，而不是tab	   
			
	 ==>paste程序：它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。paste 接受多个文件参数和／或标准输入。
			 实例：$ sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt > distros-by-date.txt
			       产生一个按照日期排序的发行版列表(排序规则是年、月、日)，并把结果存储在一个叫做 distros-by-date.txt 的文件中
			
			       $ cut -f 1,2 distros-by-date.txt > distros-versions.txt
                   $ head distros-versions.txt				   
			       使用 cut 命令从文件中抽取前两个字段（发行版名字和版本号），并把结果存储到一个名为 distro-versions.txt 的文件中
			
			       $ paste distros-dates.txt distros-versions.txt
				   
	 ==>join程序：在关系型数据库中，将来自多个享有共同关键域的表格数据结合起来，得到一个期望的结果。
            	  也即将多个具有共享关键域(共享键值)的文件的数据结合起来。
			实例：join a.txt b.txt | head
			      a.txt文件和b.txt文件具有共享键值，因此join程序执行后，两个文件的内容将会按照共享键值的对应顺序合并成一个新文件(共享键值在最前面，接着是a的数据，最后是b的数据)。
			注意：默认情况下， join 命令使用空白字符做为输入字段的界定符，一个空格作为输出字段的界定符。
			
   4)比较文本
     ==>comm程序：比较两个文本文件，并且会显示每个文件特有的文本行和共有的文本行(一定要注意，比较单位是文本行)。
            用法：comm file1.txt file2.txt  前面显示file1.txt中特有的文本行，中间是file2.txt特有的文本行，最后是两个文件共有的文本行。

     ==>diff程序：被用来监测文件之间的差异，支持许多输出格式，并且一次能处理许多文本文件。diff常见用例就是创建diff文件或者补丁，然后会被其它程序使用(例如patch程序)。
	    输出格式：a)默认模式：对两个文件之间的差异的简短描述(a 表示添加，c 表示更改(替代)，d 表示删除)
		            $diff file1.txt file2.txt    
					-->
		            
                  b)上下文模式：-c 选项指定，更改组内的文本行以四个指示符之一开头。
                        指示符：blank 上下文显示行。它并不表示两个文件之间的差异				  
                                -     删除行。这一行将会出现在第一个文件中，而不是第二个文件内。
								+     添加行。这一行将会出现在第二个文件内，而不是第一个文件中。
								!     更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。
								
				  c)统一模式：-u 选项指定，比上下文模更加简洁。
                      指示符：字符   意思
                              空格   两个文件都包含这一行。
                               -     在第一个文件中删除这一行。
                               +     添加这一行到第一个文件中。				  
								
     ==>patch程序：用来把更改应用到文本文件中，它接受从 diff 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本。
   
     完善diff和patch？？？
	 
   5)运行时编辑
     ==>tr程序：被用来更改字符，可将之看作是一种基于字符的查找和替换操作。它可以接受标准输入，进行了一系列查找替换操作后，将结果送到标准输出。
          实例：$ echo "lowercase letters" | tr a-z A-Z    将小写字母全部换为大写字母
          
		  用法：tr程序接受两个参数 "tr 参数1 参数2"，其中参数1是要被转换的字符集，参数2是相对应转换后的字符集。
		  ==>字符集表示：
                         a) 一个枚举列表。例如， ABCDEFGHIJKLMNOPQRSTUVWXYZ
                         b) 一个字符域。例如， A-Z 。注意这种方法有时候面临与其它命令相同的问题，归因于语系的排序规则，因此应该谨慎使用。
                         c) POSIX 字符类。例如， [:upper:]
             注意：一般两个字符集长度一样，然而有可能第一个集合大于第二个，尤其是我们想要把多个字符转换为单个字符时
                   $ echo "lowercase letters" | tr [:lower:] A   将第一个字符集中的小写字母全部换位单个大写字母A

          用法：除了换字之外， tr 命令能允许字符从输入流中简单地被删除。
                $tr -d '\r' < dos_file > unix_file  其中dos_file是需要被转换的文件，unix_file是转换后的结果。
		  ==>tr命令支持得转义序列和字符类别列表：tr --help
		     注意：tr程序仅在SET1 和SET2 都给出，同时没有-d 选项的时候才会进行替换，而也仅在替换时才可能用到-t 选项(如果需要将SET2补充到同SET1等长，就将SET2末尾添加原来末字符的方式)。                   

	      ==>tr程序可以执行ROT13文本编码，它是一种替换暗码的加密类型。
             例如：有时被用来隐藏文本中潜在的攻击内容，就是简单地把每个字符在字母表中向前移动 13 位，因为移动的位数是可能的 26 个字符的一半，所以对文本再次执行这个算法，就恢复到了它最初的形式。
			      $echo "secret text" | tr a-zA-Z n-za-mN-ZA-M     加密后为 frperg grkg
				  $ echo "frperg grkg" | tr a-zA-Z n-za-mN-ZA-M    解密后为 secret text
                  
          用法：使用 -s 选项， tr 命令能“挤压”（删除）重复的字符实例(第二个参数为指定字符集)
		        $echo "aaabbbccc" | tr -s abc
                注意：tr只能挤压消除相邻的重复字符，如abcabcabc便没有啥效果了

     ==>sed程序：对文本流进行编辑，要么是一系列指定的文件，要么是标准输入
	       实例：sed "front" | sed 's/front/back'
		         使用echo产生一个单词的文本流，管道给sed命令，sed命令对文本流执行s/front/back，随后输出back(类似于vi中的替换(查找和替代))
				 
           用法：sed命令开始于单个字符命令，后面跟着查找和替代字符串，斜杠字符作为分隔符(分割符是随意的，比如\_，sed将会接受紧随命令之后的任意字符作为分隔符)              
          
		   实例：$ echo "front" | sed '1s/front/back/'
           用法：sed中的大多数命令前都会带有一个地址，指定了输入流中要被编辑的文本行。最简单的地址形式是一个行号，例如 1s 表示只对仅有一行文本的输入流的第一行进行编辑(执行替换操作)
                 如果将前面的地址改成2，因为输入流没有第二行，那么会导致sed命令不被执行。
	 
		   地址表示：
		            地址         说明
                    n            行号， n 是一个正整数。
                    $            最后一行。
                    /regexp/     所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc 来指定表达式，这里
                    c            就是一个备用的字符。
                    addr1,addr2  从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意单独的地址形式。
                    first˜step    匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1˜2 是指每个位于偶数行号的文本行，5˜5 则指第五行和之后每五行位置的文本行。
			        addr1,+n     匹配地址 addr1 和随后的 n 个文本行。
                    addr!        匹配所有的文本行，除了 addr 之外， addr 可能是上述任意的地址形式。
			
		   实例：$sed -n '1,5p' distros.txt            行号
			     -p命令就是简单地把匹配的文本行打印出来，-n是为了让sed不要默认地打印每一行(不自动打印)，这里distros.txt是指定文件。
				 
				 $sed -n '/SUSE/p' distros.txt         正则表达式
				 通过包含由斜杠界定的正则表达式 \/SUSE\/，我们能够孤立出包含它的文本行，和 grep 程序的功能是相同的。
				 
				 通过给这个地址添加一个感叹号(命令p前)，我们可以否定上面的操作
				 $sed -n '/SUSE/!p' distros.txt
				 输出了文件中所有的文本行，除了那些匹配这个正则表达式的文本行
				 
		   sed编辑命令：
		         命令        说明
                 =           输出当前的行号(只是输出行号而已)。
                 a           在当前行之后追加文本。
                 d           删除当前行。
                 i           在当前行之前插入文本。
                 p           打印当前行。默认情况下， sed 程序打印每一行，并且只是编辑文件中匹配指定地址的文本行。通过指定 -n 选项，这个默认的行为能够被忽略。
                 q           退出 sed，不再处理更多的文本行。如果不指定 -n 选项，输出当前行。
				 s/regexp/replacement/    只要找到一个 regexp 匹配项，就替换为 replacement 的内容。replacement 可能包括特殊字符 &，其等价于由 regexp
				                          匹配的文本。另外， replacement 可能包含序列 \1 到 \9，其是 regexp 中相对应的子表达式的内容。更多信息，查看
                                          下面 back references 部分的讨论。在 replacement 末尾的斜杠之后，可以指定一个可选的标志，来修改 s 命令的行为。
                 y/set1/set2 执行字符转写操作，通过把 set1 中的字符转变为相对应的set2 中的字符。注意不同于 tr 程序， sed 要求两个字符集合具有相同的长度。
				 
			   1)s的编辑功能：$sed 's/regexp/replacement/' distros.txt
			     $sed 's/\([0-9]\{2\}\)\/\([0-9]\{2\}\)\/\([0-9]\{4\}\)$/\3-\1-\2/' distros.txt
			     由于表达式中额外的斜杠会迷惑 sed，而且在 sed 默认情况下，表达式中几个字符只会被当作文字字面值，并不会被当作元字符，因此使用反斜杠转义即可。
				 有 \( \) \{ \} \/ 
				 
				 未转义表达式如下：
				 $sed 's/([0-9]{2})/([0-9]{2})/([0-9]{4})$/\3-\1-\2/' distros.txt
				 这里使用的是正则表达式的逆参照功能(出现在一些使用BRE的应用程序中)，如果在 replacement 中出现了 序列 \n，这里n为数字1-9，那么这个序列指的是前面 regexp 中
				 的对应子表达式，如上即为每个()，从1开始编号。
				 
			   2)使用可选标志，跟随在替代字符串后面
			     ==>g：指示sed对某个文本行进行全范围的查找和替代操作，而不再是默认的对第一个实例进行替换操作
			     $echo "aaabbbccc" | sed 's/b/B/'    只会替换(查找和替代)第一个字符b
				 $echo "aaabbbccc" | sed 's/b/B/g'   将所有b替换成B				 
				 
	 ==>aspell程序：交互式拼写检查器(检查内容拼写)，可智能检查各种类型的文本文件(HTML文件、C/C++程序、电子邮件等)。
            1)$aspell check textfile  拼写检查一个包含简单内容的文本文件(textfile是要检查的文件名)	 
			  例如：$cat > foo.txt       
                    $aspell check foo.txt     会检查其中拼写可疑的单词并将参考单词以及其它处理操作列在下面
                    $cat foo.txt  查看修改后的文件					
				    
                    注意：除非有选项 --dont-backup 告诉 aspell 不要备份，否则 aspell 会通过追加拓展名为 .bak 的备份文件(文件名和原来一样)，该文件包含了原始文本。					
				    $sed -i 's/lazy/laxy/; s/jumped/jimped/' foo.txt   还原拼写错误
					注意：这个 -i 选项告诉sed不要把编辑结果发送到标准输出中，而是会把更改应用到文件中，以此来重新编写文件。
					      同时可以看到，可以把多个 sed 命令放在同一行中，用分号隔开即可。
				 
			  注意：当使用 aspell 命令时，若出现 bash 没有找到该命令，说明系统中没有下载 aspell，自行下载安装即可
                    $yum update aspell
                    $yum install aspell

              问题：使用 aspell 检查一个文本文件的拼写时，即 $aspell check foo.txt，报错如下:
                    错误：No word lists can be found for the language "zh_CN"???尚未解决啊。。。

22.格式化输出
    1)nl程序：添加行号，相当于 cat -n，能接受多个文件作为命令行参数，也能标准输出
      $ nl distros.txt | head
   
      选项：-b style  按要求的方式数行，其中 a = 数所有行，t = 数非空行，n = 无，pregexp = 只数那些匹配了正则表达式的行
            -f style  将footer按要求设置参数，默认是无
            -h style  将header按要求设置参数，默认是无			
			-i number 将页面增加量设置为数字，默认是1
            -n format 设置数数的格式，格式是 ln = 左偏，没有前导0；rn = 右偏，没有前导0；rz = 右偏，有前导0
            -s string 在每一行的末尾加字符作为分割符，默认是单个的tab
            -w width 设置每一行的宽度，也即是距离左边界的距离			
				
    2)fold程序：限制文件行宽(装不下的换一行显示)，接受一个或多个文件以及标准输入。如果没有字符设置，则默认是80
      $echo "THe quick brown fox jumped over the lazy dog"	| fold -w 12
       其中，-w 选项将echo命令发送的文本分解成块了。这里设置行宽为12个字符，不会因为单词边界而不会分解它。除非你加上了
       -s选项，让fold分解碰到需要分解单词的地方用空格代替，单词直接移到下一行
      $$echo "THe quick brown fox jumped over the lazy dog"	| fold -w 12 -s	   
		
     注意：折叠是将文本的行限制到特定的宽度的过程
	 
    3)fmt程序：文本格式器，同样可以折叠文本，接受文本和标准输入，并且在文本流上执行段落格式				 
				 
23.打印
   Linux系统采用两套软件配合显示和管理打印：a) GUPS 用于提供打印驱动和打印任务管理
                                              b) Ghostscript，一种PostScript解析器，作为RIP使用
  
24.shell脚本：shell脚本就是包含了一系列命令的文件，当shell读取了这个文件后，便会执行文件中的所有命令。
   1)编写一个脚本，保存为 hello_world
     #!/bin/bash                    这个 #! 字符序列是一种特殊的结构叫做 shebang，这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字，每个 shell 脚本都应该把这一文本行作为它的第一行。 
     #This is our first script.     注释(也可以放在下面命令语句中)
	 echo 'Hello World!'
     
   2)使脚本可执行，需要设置脚本文件的权限来允许其可执行
     $ls -l hello_world   
	 $chmod 755 hello_world     
	 
	 注意：权限为755 的脚本，则每个人都能执行；权限为700 的脚本，只有文件所有者能够执行。
	       为了能够执行脚本，脚本必须是可读的
   
   3)把脚本放到 shell 能够找到的地方  
	 $./hello_world  执行脚本，前面的 ./ 即是指定了脚本文件明确的路径
	 注意：为了能够运行此脚本，我们必须指定脚本文件明确的路径。如果我们没有那样做，就会提示脚本文件找不到			 
				 
	 ==>拓展：PATH 环境变量用于系统查找可执行程序，倘若没有给出可执行程序明确路径，则系统每次均会搜索一系列目录去查找(这就是为什么当我们键入 ls 后，系统知道如何执行 /bin/ls)。这个 /bin 目录就是其中一个
              系统会自动搜索的目录(该目存在了PATH环境变量中)，PATH变量包含一系列由冒号隔开的目录列表。因此只要我们的脚本文件在上述列表任一个目录下(注意是完整目录)，那么无需指定路径便可执行脚本程序。
			  
			  大多数Linux发行版本会配置PATH变量，让其中包含一个位于用户家目录下的bin目录，从而允许用户能够执行他们自己的程序。因此，我们可以自己在家目录下(如下即当前目录)创建一个 bin 目录，并把脚本文件放入其中
			  则无需指定脚本文件路径即可执行
			  [cliffchou@localhost ~]$mkdir bin
			  [cliffchou@localhost ~]$mv hello_world bin
			  [cliffchou@localhost ~]$hello_world
			  
			  echo $PATH   查看PATH变量	
			  
			  我们可以配置环境变量来使 PATH 包含内有待执行脚本文件的目录，只用在 .bashrc 文件中添加即可。
              例如：倘若PATH变量不包含位于家目录下的bin目录，可以如下添加
			  $vim .bashrc
			  export PATH=~/bin:"$PATH"	     添加新的路径(修改系统文件类型，一直有效)		  
			  注意：修改了 .bashrc 文件后，必须在新的终端会话中才会生效，因为需要然让shell重新读取这个.bashrc文件。也可以通过如下命令完成重读操作
			        $. .bashrc     #修改了 .bashrc 文件一定要记得source一下(重读)      
					该操作名为 "source".bashrc 文件，这个 . 是source命令的同义词，用来读取一个指定的shell命令文件，并把它当作是从键盘输入的一样。
                    
			  一旦添加了新的路径后，若你想删去该新路径，只需要把 .bashrc 文件中的上述语句注释掉，然后必须重启shell终端(不是source，是关闭后重启)，然后就删掉刚才添加的路径了
			  
	 注意：这个 ~/bin (家目录下的bin目录) 是存放个人所用脚本的好地方！！！ 
           倘若我们编写了一个脚本，而系统中所有用户都要使用，那么最好是放在 /usr/local/bin	 
		   系统管理员使用的脚本放在 /usr/local/sbin
		   本地支持的软件，不管是脚本还是编译过的程序，都应该放到 /usr/local 目录下，而不是在/bin 或/usr/bin 目录下	 
				 
				 
				 
				 
				 
				 
				 
				 
				 
				 
			
			
			
			
			
			
			
			
			
	
	