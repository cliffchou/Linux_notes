1.exit 关闭终端
2.在Linux文件系统中跳转 
  • pwd —打印出当前工作目录名 
  • cd —更改目录 
  • ls —列出目录内容
  
  快捷键：  
  cd 更改工作目录到你的家目录。 
  cd - 更改工作目录到先前的工作目录。 
  cd ˜user name 更改工作目录到用户家目录。例如, cd ˜bob 会更改工作目 录到用户“bob”的家目录。
  
3.有利于研究linux系统的命令 
  • ls —列出目录内容。
       —除了当前目录外，也可以指定要列出内容的目录，例如 $ ls /usr 。甚至可以列出多个指定目录的内容，例如 $ ls ~ /usr 将列出用户家目录和/usr目录的内容。
	   —ls -l 结果以长模式输出
  • ﬁle —确定文件类型（file filename 会打印文件内容的简单描述） 
  • less —浏览文件内容(less filename 允许你上下滚动文件，按“q”键退出less程序)
  
  ls命令的选项：
  选项 长选项
  -a   --all 列出所有文件，甚至包括文件名以圆点开头的默认会 被隐藏的隐藏文件。
  -d   --directory 通常，如果指定了目录名，ls 命令会列出这个目录中 的内容，而不是目录本身。把这个选项与 -l 选项结合 使用，可以看到所指定目录的详细信息，而不是目录中的内容。 
  -F   --classify 这个选项会在每个所列出的名字后面加上一个指示 符。例如，如果名字是目录名，则会加上一个’/’ 字 符。 
  -h   --human-readable 当以长格式列出时，以人们可读的格式，而不是以字 节数来显示文件的大小。 
  -l 以长格式显示结果。 
  -r   --reverse 以相反的顺序来显示结果。通常，ls 命令的输出结果 按照字母升序排列。 
  -S 命令输出结果按照文件大小来排序。 
  -t 按照修改时间来排序。

  less程序最常用的键盘命令：
  命令                行为
  Page UP or b        向上翻滚一页（page UP在键盘上面有）
  Page Down or space  向下翻滚一页
  UP Arrow            向上翻滚一行（上箭头）
  Down Arrow          向下翻滚一行
  G                   移动到最后一行
  1G or g             移动到开头一行
  /charaters          向前查找指定的字符串
  n                   向前查找下一个出现的字符串，这个字符串是之前所指定查找的
  h                   显示帮助屏幕
  q                   退出 less 程序

4.操作文件和目录
  • cp —复制文件和目录（cp item1 item2; cp item... directory 复制一个或多个项目（或文件）到后面哪个目标目录（或文件）下）
  • mv —移动/重命名文件和目录
  • mkdir —创建目录
  • rm —删除文件和目录（rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变）
  • ln —创建硬链接和符号链接（ln file link 创建硬链接；ln -s item link 创建软链接，item可以是一个文件或是一个目录）

===>>
===>>

  通配符：
  通配符          意义
  *               匹配任意多个字符（包括零个或一个）
  ?               匹配任意一个字符（不包括零个）
  [characters]    匹配任意一个属于字符集中的字符
  [!characters]   匹配任意一个不是字符集中的字符
  [[:class:]]     匹配任意一个属于指定字符类中的字符
  
  最常用的字符类：
  字符类          意义
  [:alnum:]       匹配任意一个字母或数字
  [:alpha:]       匹配任意一个字母
  [:digit:]       匹配任意一个数字
  [:lower:]       匹配任意一个小写字母
  [:upper]        匹配任意一个大写字母
  
  范例：
  模式            匹配对象
  *               所有文件
  g*              文件名以“g”开头的文件
  b*.txt          以”b” 开头，中间有零个或任意多个字符，并以”.txt” 结尾的文件
  Data???         以“Data”开头，其后紧接着 3 个字符的文件
  [abc]*          文件名以”a”,”b”, 或”c” 开头的文件
  BACKUP.[0-9][0-9][0-9] 以”BACKUP.” 开头，并紧接着 3 个数字的文件
  [[:upper:]]*    以大写字母开头的文件
  [![:digit:]]*   不以数字开头的文件
  *[[:lower:]123] 文件名以小写字母结尾，或以“1”，“2”，或“3”结尾的文件
  
  cp命令一些有用选项：
  选项                   意义 
  -a, --archive          复制文件和目录，以及它们的属性，包括所有权和权限。通常，复本具有用户所操作文件的默认属性。 
  -i, --interactive      在重写已存在文件之前，提示用户确认。如果这个选项不指定，cp命令会默认重写文件。 
  -r, --recursive        递归地复制目录及目录中的内容。当复制目录时，需要这个选项（或者 -a 选项）。 
  -u, --update           当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 
  -v, --verbose          显示翔实的命令操作信息
  -b                     文件被覆盖之前做简单备份（-b不接受参数，）
  
  mv命令一些有用选项：
  选项                  意义 
  -i --interactive      在重写一个已经存在的文件之前，提示用户确认信息。 mv命令本来就会提示是否覆盖，只要不加入 -f 即可。 
  -u --update           当把文件从一个目录移动另一个目录时，只是移动不存在的文件，或者文件内容新于目标目录相对应文件的内容。 
  -v --verbose          当操作 mv 命令时，显示翔实的操作信息
  典例：mv * ../ 移动当前文件夹下的所有文件到上一级目录
        mv test3/*.txt test2 把当前目录的一个子目录里的文件移动到另一个子目录里
  注意：1) mv dir1 dir2 目录的移动，但若目录dir2不存在，则会将dir1改名为dir2.
        2) 你只能操作当前目录下的目录（或文件）及其子目录（或文件），而且当前目录下，若不指定目标目录，那么默认目标目录是当前目录。
           例如：mv file1/xiu.txt xiuxiu.txt 先将file1中的文件改名，再移动到当前目录中来（其实 xiuxiu.txt 实际为/xiuxiu.txt） 		
        3) 移动还是改名，就看目标对象到底是目录（dir,file），还是文件（.txt, .log ...）。其实本质上讲都是移动，不存在的再创建一个，移动后再删除原来的，看起来就像改了名一样，神奇不。
  
  rm命令一些有用选项：
  选项                  意义 
  -i, --interactive     在删除已存在的文件前，提示用户确认信息。 如果不指定 这个选项，rm 会默默地删除文件 
  -r, --recursive       递归地删除文件，这意味着，如果要删除一个目录，而此目录又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 
  -f, --force           忽视不存在的文件，不显示提示信息。这选项颠覆了“-interactive”选项。 
  -v, --verbose         在执行 rm 命令时，显示翔实的操作信息。
  注意：rm 无法直接删除一个目录，必须用-i递归删除
  
  ln创建硬链接和符号链接：
  1) ls -li 展示索引节点的信息
  
5.man 显示程序手册页(命令的帮助文档)

  man 所显示的参考手册是分章节的，以下细分之...
  章节      内容
   1        用户命令
   2        程序接口内核系统调用
   3        C 库函数程序接口
   4        特殊文件，比如说设备结点和驱动程序
   5        文件格式
   6        游戏娱乐，如屏幕保护程序
   7        其他方面
   8        系统管理员命令
  
  apropos 显示适当的命令（可以基于某个关键字的匹配项，搜索参考手册列表）
  注意：man命令加上“-k”选项，和apropos完成一样的功能
  
  whatis 显示非常简洁的命令说明（whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明）
  
  info 显示程序 Info 条目
  当显示一个info页面时，以下命令用来控制阅读器：
  命令                行为
   ?                  显示命令帮助
  PgUp or Backspace   显示上一页
  PgDn or Space       显示下一页
   n                  下一个 - 显示下一个结点
   p                  上一个 - 显示上一个结点
   u Up - 显示当前所显示结点的父结点，通常是个菜单
   Enter               激活光标位置下的超级链接
   q                  退出
    
7. 用别名（alias）创建你自己的命令: alias name='string'
   1) 创建之前，建议先用 type 命令查看下该名字是否已被占用；
   2) 然后再通过 alias 创建属于自己的命令，如 $ alias foo='cd /usr; ls; cd ~'
   3) 删除别名，用 unalias 命令，如 $ unalias foo
   
8.I/O重定向
  • cat    －连接文件（命令读取一个或多个文件，然后复制它们到标准输出，cat [file]）
  • sort   －排序文本行
  • uniq   －报道或省略重复行
  • grep   －打印匹配行
  • wc     －打印文件中换行符，字，和字节个数
  • head   －输出文件第一部分
  • tail   －输出文件最后一部分 
   
==>重定向标准输出：$ ls -l /bin/usr > ls-output.txt
                          存在的目录  重定向标准输出目标文件
   
   删除一个文件内容（或创建一个新的空文件）：$ > ls-output.txt 
   因为当我们使用 “>” 重定向符来重定向输出结果时，目标文件总是从开头被重写。也就是说简单地使用重定向符，没有命令在它之前，这会删除一个已存在文件的内容或是创建一个新的空文件。
   
==>重定向标准错误：$ ls -l /bin/usr 2> ls-error.txt      此处是 /bin/usr ，即只有错误输出才能输出到该重定向文件中，倘若你用 /usr/bin 表示，只能在屏幕上输出文本内容，并不能输出到该重定向文件中
   注意：因为标准错误和文件描述符 2 一样，所以我们用文本描述符来重定向标准错误。文件描述符 “2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt任务。
         同理，>> 表示不会删除目标文件中原有的内容，而是接着在其后面输出标准错误
   
==>重定向标准输出、标准错误到同一个文件：1)$ ls -l /bin/usr > ls-output.txt 2>&1     注意 2>&1 这几个命令是紧挨在一起的
                                           该方法完成了两个重定向，首先重定向标准输出到文件 ls-output.txt，然后重定向文件描述符 2（标准错误）到文件描述符 1（标准输出）使用表示法 2>&1。  
                                         2)$ ls -l /bin/usr &> ls-output.txt
										   我们使用单单一个表示法 &> 来重定向标准输出和错误到文件 lsoutput.txt
   注意：重定向是一个“一次性”操作，并不是说你重定向一次就一劳永逸了，每次你不指定系统就默认输出到屏幕上去
   
   
==>重定向标准输入
   1)由于文件名参数的缺席， cat 复制标准输入到标准输出，所以我们看到文本行重复出现。我们可以使用这种行为来创建简短的文本文件
     $ cat > lazy_dog.txt          记得最后输入 Ctrl-d
   2)"<" 重定向标准输入： $ cat < lazy_dog.txt 将标准输入从键盘重定向为 lazy_dog.txt 文件
   
==>管道线：|  使用管道操作符“|”（竖杠），一个命令的标准输出可以管道到另一个命令的标准输入
   例如：less 可以接受标准输入，因此我们可以利用less命令一页一页地显示任何命令的输出，把它们的运行结果送到标准输出
         $ls -l /usr/bin | less   我们可以方便地检测会产生标准输出的任一命令的运行结果
   
   
   
   
   
   
   
   
   
   
   
   
  
  
  
  
  
  
  
  
  
  
  
  
  